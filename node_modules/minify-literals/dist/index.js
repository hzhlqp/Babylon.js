// lib/index.ts
import MagicString from "magic-string";
import { parseLiterals } from "parse-literals";

// lib/strategy.ts
import CleanCSS from "clean-css";
import { minify } from "html-minifier-terser";
var defaultMinifyCSSOptions = {};
var defaultMinifyOptions = {
  caseSensitive: true,
  collapseWhitespace: true,
  decodeEntities: true,
  minifyCSS: defaultMinifyCSSOptions,
  minifyJS: true,
  processConditionalComments: true,
  removeAttributeQuotes: false,
  removeComments: true,
  removeEmptyAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  useShortDoctype: true
};
var defaultStrategy = {
  getPlaceholder(parts) {
    const suffix = "();";
    let placeholder = "@TEMPLATE_EXPRESSION";
    while (parts.some((part) => part.text.includes(placeholder + suffix))) {
      placeholder += "_";
    }
    return placeholder + suffix;
  },
  combineHTMLStrings(parts, placeholder) {
    return parts.map((part) => part.text).join(placeholder);
  },
  async minifyHTML(html, options = {}) {
    let minifyCSSOptions;
    if (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\(\);(.*?)-->/g)) {
      console.warn(
        "minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped."
      );
      return html;
    }
    html = html.replaceAll("<@TEMPLATE_EXPRESSION();", "<TEMPLATE_EXPRESSION___");
    html = html.replaceAll("</@TEMPLATE_EXPRESSION();", "</TEMPLATE_EXPRESSION___");
    if (options.minifyCSS) {
      if (options.minifyCSS !== true && typeof options.minifyCSS !== "function") {
        minifyCSSOptions = { ...options.minifyCSS };
      } else {
        minifyCSSOptions = {};
      }
    } else {
      minifyCSSOptions = false;
    }
    let adjustedMinifyCSSOptions = false;
    if (minifyCSSOptions) {
      adjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);
    }
    let result = await minify(html, {
      ...options,
      minifyCSS: adjustedMinifyCSSOptions
    });
    result = result.replaceAll("<TEMPLATE_EXPRESSION___", "<@TEMPLATE_EXPRESSION();");
    result = result.replaceAll("</TEMPLATE_EXPRESSION___", "</@TEMPLATE_EXPRESSION();");
    if (options.collapseWhitespace) {
      const matches = Array.from(result.matchAll(/<svg/g)).reverse();
      for (const match of matches) {
        const startTagIndex = match.index ?? 0;
        const closeTagIndex = result.indexOf("</svg", startTagIndex);
        if (closeTagIndex < 0) {
          continue;
        }
        const start = result.substring(0, startTagIndex);
        let svg = result.substring(startTagIndex, closeTagIndex);
        const end = result.substring(closeTagIndex);
        svg = svg.replace(/\r?\n/g, "");
        result = start + svg + end;
      }
    }
    result = fixCleanCssTidySelectors(html, result);
    return result;
  },
  async minifyCSS(css, options = {}) {
    const adjustedOptions = adjustMinifyCSSOptions(options);
    css = css.replaceAll(/@TEMPLATE_EXPRESSION\(\);:/g, "--TEMPLATE-EXPRESSION:");
    const output = await new CleanCSS({
      ...adjustedOptions,
      returnPromise: true
    }).minify(css);
    if (output.errors?.length)
      throw new Error(output.errors.join("\n\n"));
    if (output.warnings?.length)
      console.log(css, output.styles);
    if (output.warnings.length) {
      console.warn(output.warnings.join("\n\n"));
      console.warn(
        "minify-literals: warnings during CSS minification, file was skipped. See above for details."
      );
      return css.replace(/(\n)|(\r)/g, "");
    }
    output.styles = output.styles.replaceAll("--TEMPLATE-EXPRESSION:", "@TEMPLATE_EXPRESSION();:");
    output.styles = fixCleanCssTidySelectors(css, output.styles);
    return output.styles;
  },
  splitHTMLByPlaceholder(html, placeholder) {
    const parts = html.split(placeholder);
    if (placeholder.endsWith(";")) {
      const withoutSemicolon = placeholder.substring(0, placeholder.length - 1);
      for (let i = parts.length - 1; i >= 0; i--) {
        parts.splice(i, 1, ...parts[i]?.split(withoutSemicolon) ?? []);
      }
    }
    return parts;
  }
};
function adjustMinifyCSSOptions(options = {}) {
  const level = options.level;
  const plugin = {
    level1: {
      value: (_name, value) => {
        if (!value.startsWith("@TEMPLATE_EXPRESSION") || value.endsWith(";"))
          return value;
        return `${value};`;
      }
    }
  };
  return {
    ...options,
    level,
    plugins: [plugin]
  };
}
function fixCleanCssTidySelectors(original, result) {
  const regex = /(::?.+\((.*)\))[\s\r\n]*{/gm;
  let match;
  while ((match = regex.exec(original)) != null) {
    const pseudoClass = match[1] ?? "";
    const parameters = match[2];
    if (!parameters?.match(/\s/)) {
      continue;
    }
    const parametersWithoutSpaces = parameters.replace(/\s/g, "");
    const resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);
    const resultStartIndex = result.indexOf(resultPseudoClass);
    if (resultStartIndex < 0) {
      continue;
    }
    const resultEndIndex = resultStartIndex + resultPseudoClass.length;
    result = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);
  }
  return result;
}

// lib/index.ts
function defaultGenerateSourceMap(ms, fileName) {
  return ms.generateMap({
    file: `${fileName}.map`,
    source: fileName,
    hires: true
  });
}
function defaultShouldMinify(template) {
  const tag = template.tag?.toLowerCase();
  return !!tag && (tag.includes("html") || tag.includes("svg"));
}
function defaultShouldMinifyCSS(template) {
  if (!template?.tag?.toLowerCase().includes("css"))
    return false;
  return true;
}
var defaultValidation = {
  ensurePlaceholderValid(placeholder) {
    if (typeof placeholder !== "string" || !placeholder.length) {
      throw new Error("getPlaceholder() must return a non-empty string");
    }
  },
  ensureHTMLPartsValid(parts, htmlParts) {
    if (parts.length !== htmlParts.length) {
      throw new Error("splitHTMLByPlaceholder() must return same number of strings as template parts");
    }
  }
};
async function minifyHTMLLiterals(source, options = {}) {
  options.MagicString = options.MagicString || MagicString;
  options.parseLiterals = options.parseLiterals || parseLiterals;
  options.shouldMinify = options.shouldMinify || defaultShouldMinify;
  options.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;
  options.minifyOptions = {
    ...defaultMinifyOptions,
    ...options.minifyOptions
  };
  options.parseLiteralsOptions = {
    fileName: options.fileName,
    ...options.parseLiteralsOptions
  };
  const templates = options.parseLiterals(source, options.parseLiteralsOptions);
  const strategy = options.strategy || defaultStrategy;
  const { shouldMinify, shouldMinifyCSS } = options;
  let validate;
  if (options.validate !== false) {
    validate = options.validate || defaultValidation;
  }
  let skipCSS = false;
  let skipHTML = false;
  if (strategy.minifyCSS && source.includes("unsafeCSS")) {
    console.warn(
      `minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`
    );
    skipCSS = true;
  }
  if (source.includes("unsafeHTML")) {
    console.warn(
      `minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`
    );
    skipHTML = true;
  }
  if (!options.MagicString)
    throw new Error("MagicString is required, this should never happen");
  const ms = new options.MagicString(source);
  const promises = templates.map(async (template) => {
    const minifyHTML = !skipHTML && shouldMinify(template);
    const minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);
    if (!(minifyHTML || minifyCSS))
      return;
    const placeholder = strategy.getPlaceholder(template.parts);
    if (validate) {
      validate.ensurePlaceholderValid(placeholder);
    }
    const combined = strategy.combineHTMLStrings(template.parts, placeholder);
    let min;
    if (minifyCSS) {
      const minifyCSSOptions = options.minifyOptions?.minifyCSS;
      if (typeof minifyCSSOptions === "function") {
        min = minifyCSSOptions(combined);
      } else if (minifyCSSOptions === false) {
        min = combined;
      } else {
        const cssOptions = typeof minifyCSSOptions === "object" ? minifyCSSOptions : void 0;
        min = await strategy.minifyCSS?.(combined, cssOptions) ?? combined;
      }
    } else {
      min = await strategy.minifyHTML(combined, options.minifyOptions);
    }
    const minParts = strategy.splitHTMLByPlaceholder(min, placeholder);
    if (validate)
      validate.ensureHTMLPartsValid(template.parts, minParts);
    for (const [index, part] of template.parts.entries()) {
      if (part.start < part.end)
        ms.overwrite(part.start, part.end, minParts[index] ?? "");
    }
  });
  await Promise.all(promises);
  const sourceMin = ms.toString();
  if (source === sourceMin)
    return null;
  let map;
  if (options.generateSourceMap !== false) {
    const generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;
    map = generateSourceMap(ms, options.fileName || "");
  }
  return {
    map,
    code: sourceMin
  };
}
export {
  defaultGenerateSourceMap,
  defaultShouldMinify,
  defaultShouldMinifyCSS,
  defaultValidation,
  minifyHTMLLiterals
};
//# sourceMappingURL=index.js.map