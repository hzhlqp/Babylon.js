{"version":3,"sources":["../lib/index.ts","../lib/strategy.ts"],"sourcesContent":["import MagicString, { type SourceMapOptions } from \"magic-string\";\nimport { type Template, type TemplatePart, type ParseLiteralsOptions, parseLiterals } from \"parse-literals\";\nimport { type Strategy, defaultMinifyOptions, defaultStrategy } from \"./strategy.js\";\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport type Options = DefaultOptions | CustomOptions<any>;\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using default html-minifier\n * strategy.\n */\nexport interface DefaultOptions extends BaseOptions {\n\t/**\n\t * <code>html-minifier</code> options to use. Defaults to\n\t * <code>defaultMinifyOptions</code>, for production-ready minification.\n\t */\n\tminifyOptions?: Partial<typeof defaultMinifyOptions>;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>, using a custom strategy.\n */\nexport interface CustomOptions<S extends Strategy> extends BaseOptions {\n\t/**\n\t * HTML minification options.\n\t */\n\tminifyOptions?: S extends Strategy<infer O> ? Partial<O> : never;\n\t/**\n\t * Override the default strategy for how to minify HTML. The default is to\n\t * use <code>html-minifier</code>.\n\t */\n\tstrategy: S;\n}\n\n/**\n * Options for <code>minifyHTMLLiterals()</code>.\n */\nexport interface BaseOptions {\n\t/**\n\t * The name of the file. This is used to determine how to parse the source\n\t * code and for source map filenames. It may be a base name, relative, or\n\t * absolute path.\n\t */\n\tfileName?: string;\n\t/**\n\t * Override how source maps are generated. Set to false to disable source map\n\t * generation.\n\t *\n\t * @param ms the MagicString instance with code modifications\n\t * @param fileName the name or path of the file\n\t * @returns a v3 SourceMap or undefined\n\t */\n\tgenerateSourceMap?: ((ms: MagicStringLike, fileName: string) => SourceMap | undefined) | false;\n\t/**\n\t * The MagicString-like constructor to use. MagicString is used to replace\n\t * strings and generate source maps.\n\t *\n\t * Override if you want to set your own version of MagicString or change how\n\t * strings are overridden. Use <code>generateSourceMap</code> if you want to\n\t * change how source maps are created.\n\t */\n\tMagicString?: { new (source: string): MagicStringLike };\n\t/**\n\t * Override how template literals are parsed from a source string.\n\t */\n\tparseLiterals?: typeof parseLiterals;\n\t/**\n\t * Options for <code>parseLiterals()</code>.\n\t */\n\tparseLiteralsOptions?: Partial<ParseLiteralsOptions>;\n\t/**\n\t * Determines whether or not a template should be minified. The default is to\n\t * minify all tagged template whose tag name contains \"html\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinify?(template: Template): boolean;\n\t/**\n\t * Determines whether or not a CSS template should be minified. The default is\n\t * to minify all tagged template whose tag name contains \"css\" (case\n\t * insensitive).\n\t *\n\t * @param template the template to check\n\t * @returns true if the template should be minified\n\t */\n\tshouldMinifyCSS?(template: Template): boolean;\n\t/**\n\t * Override custom validation or set to false to disable validation. This is\n\t * only useful when implementing your own strategy that may return\n\t * unexpected results.\n\t */\n\tvalidate?: Validation | false;\n}\n\n/**\n * A MagicString-like instance. <code>minify-literals</code> only uses a\n * subset of the MagicString API to overwrite the source code and generate\n * source maps.\n */\nexport interface MagicStringLike {\n\tgenerateMap(options?: Partial<SourceMapOptions>): SourceMap;\n\toverwrite(start: number, end: number, content: string): any;\n\ttoString(): string;\n}\n\n/**\n * A v3 SourceMap.\n *\n * <code>magic-string> incorrectly declares the SourceMap type with a version\n * string instead of a number, so <code>minify-literals</code> declares\n * its own type.\n */\nexport interface SourceMap {\n\tversion: number | string;\n\tfile: string | null;\n\tsources: Array<string | null>;\n\tsourcesContent: Array<string | null>;\n\tnames: string[];\n\tmappings: string;\n\ttoString(): string;\n\ttoUrl(): string;\n}\n\n/**\n * Validation that is executed when minifying HTML to ensure there are no\n * unexpected errors. This is to alleviate hard-to-troubleshoot errors such as\n * undefined errors.\n */\nexport interface Validation {\n\t/**\n\t * Throws an error if <code>strategy.getPlaceholder()</code> does not return\n\t * a valid placeholder string.\n\t *\n\t * @param placeholder the placeholder to check\n\t */\n\tensurePlaceholderValid(placeholder: any): void;\n\t/**\n\t * Throws an error if <code>strategy.splitHTMLByPlaceholder()</code> does not\n\t * return an HTML part string for each template part.\n\t *\n\t * @param parts the template parts that generated the strings\n\t * @param htmlParts the split HTML strings\n\t */\n\tensureHTMLPartsValid(parts: TemplatePart[], htmlParts: string[]): void;\n}\n\n/**\n * The result of a call to <code>minifyHTMLLiterals()</code>.\n */\nexport interface Result {\n\t/**\n\t * The minified code.\n\t */\n\tcode: string;\n\t/**\n\t * Optional v3 SourceMap for the code.\n\t */\n\tmap?: SourceMap | undefined;\n}\n\n/**\n * The default method to generate a SourceMap. It will generate the SourceMap\n * from the provided MagicString instance using \"fileName.map\" as the file and\n * \"fileName\" as the source.\n *\n * @param ms the MagicString instance with code modifications\n * @param fileName the name of the source file\n * @returns a v3 SourceMap\n */\nexport function defaultGenerateSourceMap(ms: MagicStringLike, fileName: string) {\n\treturn ms.generateMap({\n\t\tfile: `${fileName}.map`,\n\t\tsource: fileName,\n\t\thires: true,\n\t});\n}\n\n/**\n * The default method to determine whether or not to minify a template. It will\n * return true for all tagged templates whose tag name contains \"html\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinify(template: Template) {\n\tconst tag = template.tag?.toLowerCase();\n\treturn !!tag && (tag.includes(\"html\") || tag.includes(\"svg\"));\n}\n\n/**\n * The default method to determine whether or not to minify a CSS template. It\n * will return true for all tagged templates whose tag name contains \"css\" (case\n * insensitive).\n *\n * @param template the template to check\n * @returns true if the template should be minified\n */\nexport function defaultShouldMinifyCSS(template: Template) {\n\tif (!template?.tag?.toLowerCase().includes(\"css\")) return false;\n\treturn true;\n}\n\n/**\n * The default validation.\n */\nexport const defaultValidation: Validation = {\n\tensurePlaceholderValid(placeholder) {\n\t\tif (typeof placeholder !== \"string\" || !placeholder.length) {\n\t\t\tthrow new Error(\"getPlaceholder() must return a non-empty string\");\n\t\t}\n\t},\n\tensureHTMLPartsValid(parts, htmlParts) {\n\t\tif (parts.length !== htmlParts.length) {\n\t\t\tthrow new Error(\"splitHTMLByPlaceholder() must return same number of strings as template parts\");\n\t\t}\n\t},\n};\n\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals(source: string, options?: DefaultOptions): Promise<Result | null>;\n/**\n * Minifies all HTML template literals in the provided source string.\n *\n * @param source the source code\n * @param options minification options\n * @returns the minified code, or null if no minification occurred.\n */\nexport async function minifyHTMLLiterals<S extends Strategy>(\n\tsource: string,\n\toptions?: CustomOptions<S>,\n): Promise<Result | null>;\n\nexport async function minifyHTMLLiterals(source: string, options: Options = {}): Promise<Result | null> {\n\toptions.MagicString = (options.MagicString || MagicString) as typeof options.MagicString;\n\toptions.parseLiterals = options.parseLiterals || parseLiterals;\n\toptions.shouldMinify = options.shouldMinify || defaultShouldMinify;\n\toptions.shouldMinifyCSS = options.shouldMinifyCSS || defaultShouldMinifyCSS;\n\n\toptions.minifyOptions = {\n\t\t...defaultMinifyOptions,\n\t\t...options.minifyOptions,\n\t};\n\n\toptions.parseLiteralsOptions = {\n\t\tfileName: options.fileName,\n\t\t...options.parseLiteralsOptions,\n\t};\n\n\tconst templates = options.parseLiterals(source, options.parseLiteralsOptions);\n\tconst strategy = <Strategy>(<CustomOptions<any>>options).strategy || defaultStrategy;\n\tconst { shouldMinify, shouldMinifyCSS } = options;\n\tlet validate: Validation | undefined;\n\tif (options.validate !== false) {\n\t\tvalidate = options.validate || defaultValidation;\n\t}\n\n\tlet skipCSS = false;\n\tlet skipHTML = false;\n\n\tif (strategy.minifyCSS && source.includes(\"unsafeCSS\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeCSS() detected in source. CSS minification will not be performed for this file.`,\n\t\t);\n\t\tskipCSS = true;\n\t}\n\n\tif (source.includes(\"unsafeHTML\")) {\n\t\tconsole.warn(\n\t\t\t`minify-literals: unsafeHTML() detected in source. HTML minification will not be performed for this file.`,\n\t\t);\n\t\tskipHTML = true;\n\t}\n\n\tif (!options.MagicString) throw new Error(\"MagicString is required, this should never happen\");\n\tconst ms = new options.MagicString(source);\n\n\tconst promises = templates.map(async (template) => {\n\t\tconst minifyHTML = !skipHTML && shouldMinify(template);\n\t\tconst minifyCSS = !skipCSS && strategy.minifyCSS && shouldMinifyCSS(template);\n\n\t\tif (!(minifyHTML || minifyCSS)) return;\n\n\t\tconst placeholder = strategy.getPlaceholder(template.parts);\n\t\tif (validate) {\n\t\t\tvalidate.ensurePlaceholderValid(placeholder);\n\t\t}\n\n\t\tconst combined = strategy.combineHTMLStrings(template.parts, placeholder);\n\t\tlet min: string;\n\n\t\tif (minifyCSS) {\n\t\t\tconst minifyCSSOptions = (options as DefaultOptions).minifyOptions?.minifyCSS;\n\t\t\tif (typeof minifyCSSOptions === \"function\") {\n\t\t\t\tmin = minifyCSSOptions(combined);\n\t\t\t} else if (minifyCSSOptions === false) {\n\t\t\t\tmin = combined;\n\t\t\t} else {\n\t\t\t\tconst cssOptions = typeof minifyCSSOptions === \"object\" ? minifyCSSOptions : undefined;\n\t\t\t\tmin = (await strategy.minifyCSS?.(combined, cssOptions)) ?? combined;\n\t\t\t}\n\t\t} else {\n\t\t\tmin = await strategy.minifyHTML(combined, options.minifyOptions);\n\t\t}\n\n\t\tconst minParts = strategy.splitHTMLByPlaceholder(min, placeholder);\n\t\tif (validate) validate.ensureHTMLPartsValid(template.parts, minParts);\n\n\t\tfor (const [index, part] of template.parts.entries()) {\n\t\t\tif (part.start < part.end)\n\t\t\t\t// Only overwrite if the literal part has text content\n\t\t\t\tms.overwrite(part.start, part.end, minParts[index] ?? \"\");\n\t\t}\n\t});\n\n\tawait Promise.all(promises);\n\n\tconst sourceMin = ms.toString();\n\n\tif (source === sourceMin) return null;\n\n\tlet map: SourceMap | undefined;\n\tif (options.generateSourceMap !== false) {\n\t\tconst generateSourceMap = options.generateSourceMap || defaultGenerateSourceMap;\n\t\tmap = generateSourceMap(ms, options.fileName || \"\");\n\t}\n\n\treturn {\n\t\tmap,\n\t\tcode: sourceMin,\n\t};\n}\n","import CleanCSS from \"clean-css\";\nimport { type Options as HTMLOptions, minify } from \"html-minifier-terser\";\nimport type { TemplatePart } from \"parse-literals\";\n\n/**\n * A strategy on how to minify HTML and optionally CSS.\n *\n * @template O minify HTML options\n * @template C minify CSS options\n */\nexport interface Strategy<O = any, C = any> {\n\t/**\n\t * Retrieve a placeholder for the given array of template parts. The\n\t * placeholder returned should be the same if the function is invoked with the\n\t * same array of parts.\n\t *\n\t * The placeholder should be an HTML-compliant string that is not present in\n\t * any of the parts' text.\n\t *\n\t * @param parts the parts to get a placeholder for\n\t * @returns the placeholder\n\t */\n\tgetPlaceholder(parts: TemplatePart[]): string;\n\t/**\n\t * Combines the parts' HTML text strings together into a single string using\n\t * the provided placeholder. The placeholder indicates where a template\n\t * expression occurs.\n\t *\n\t * @param parts the parts to combine\n\t * @param placeholder the placeholder to use between parts\n\t * @returns the combined parts' text strings\n\t */\n\tcombineHTMLStrings(parts: TemplatePart[], placeholder: string): string;\n\t/**\n\t * Minfies the provided HTML string.\n\t *\n\t * @param html the html to minify\n\t * @param options html minify options\n\t * @returns minified HTML string\n\t */\n\tminifyHTML(html: string, options?: O): Promise<string>;\n\t/**\n\t * Minifies the provided CSS string.\n\t *\n\t * @param css the css to minfiy\n\t * @param options css minify options\n\t * @returns minified CSS string\n\t */\n\tminifyCSS?(css: string, options?: C): Promise<string>;\n\t/**\n\t * Splits a minfied HTML string back into an array of strings from the\n\t * provided placeholder. The returned array of strings should be the same\n\t * length as the template parts that were combined to make the HTML string.\n\t *\n\t * @param html the html string to split\n\t * @param placeholder the placeholder to split by\n\t * @returns an array of html strings\n\t */\n\tsplitHTMLByPlaceholder(html: string, placeholder: string): string[];\n}\n\n/**\n * The default <code>clean-css</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyCSSOptions: CleanCSS.Options = {};\n\n/**\n * The default <code>html-minifier</code> options, optimized for production\n * minification.\n */\nexport const defaultMinifyOptions: HTMLOptions = {\n\tcaseSensitive: true,\n\tcollapseWhitespace: true,\n\tdecodeEntities: true,\n\tminifyCSS: defaultMinifyCSSOptions,\n\tminifyJS: true,\n\tprocessConditionalComments: true,\n\tremoveAttributeQuotes: false,\n\tremoveComments: true,\n\tremoveEmptyAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tuseShortDoctype: true,\n};\n\n/**\n * The default strategy. This uses <code>html-minifier</code> to minify HTML and\n * <code>clean-css</code> to minify CSS.\n */\nexport const defaultStrategy: Strategy<HTMLOptions, CleanCSS.Options> = {\n\tgetPlaceholder(parts) {\n\t\t// Using @ and (); will cause the expression not to be removed in CSS.\n\t\t// However, sometimes the semicolon can be removed (ex: inline styles).\n\t\t// In those cases, we want to make sure that the HTML splitting also\n\t\t// accounts for the missing semicolon.\n\t\tconst suffix = \"();\";\n\t\tlet placeholder = \"@TEMPLATE_EXPRESSION\";\n\t\twhile (parts.some((part) => part.text.includes(placeholder + suffix))) {\n\t\t\tplaceholder += \"_\";\n\t\t}\n\n\t\treturn placeholder + suffix;\n\t},\n\n\tcombineHTMLStrings(parts, placeholder) {\n\t\treturn parts.map((part) => part.text).join(placeholder);\n\t},\n\n\tasync minifyHTML(html, options = {}) {\n\t\tlet minifyCSSOptions: HTMLOptions[\"minifyCSS\"];\n\n\t\tif (html.match(/<!--(.*?)@TEMPLATE_EXPRESSION\\(\\);(.*?)-->/g)) {\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: HTML minification is not supported for template expressions inside comments. Minification for this file will be skipped.\",\n\t\t\t);\n\t\t\treturn html;\n\t\t}\n\n\t\thtml = html.replaceAll(\"<@TEMPLATE_EXPRESSION();\", \"<TEMPLATE_EXPRESSION___\");\n\t\thtml = html.replaceAll(\"</@TEMPLATE_EXPRESSION();\", \"</TEMPLATE_EXPRESSION___\");\n\n\t\tif (options.minifyCSS) {\n\t\t\tif (options.minifyCSS !== true && typeof options.minifyCSS !== \"function\") {\n\t\t\t\tminifyCSSOptions = { ...options.minifyCSS };\n\t\t\t} else {\n\t\t\t\tminifyCSSOptions = {};\n\t\t\t}\n\t\t} else {\n\t\t\tminifyCSSOptions = false;\n\t\t}\n\n\t\tlet adjustedMinifyCSSOptions: false | ReturnType<typeof adjustMinifyCSSOptions> = false;\n\t\tif (minifyCSSOptions) {\n\t\t\tadjustedMinifyCSSOptions = adjustMinifyCSSOptions(minifyCSSOptions);\n\t\t}\n\n\t\tlet result = await minify(html, {\n\t\t\t...options,\n\t\t\tminifyCSS: adjustedMinifyCSSOptions,\n\t\t});\n\n\t\tresult = result.replaceAll(\"<TEMPLATE_EXPRESSION___\", \"<@TEMPLATE_EXPRESSION();\");\n\t\tresult = result.replaceAll(\"</TEMPLATE_EXPRESSION___\", \"</@TEMPLATE_EXPRESSION();\");\n\n\t\tif (options.collapseWhitespace) {\n\t\t\t// html-minifier does not support removing newlines inside <svg>\n\t\t\t// attributes. Support this, but be careful not to remove newlines from\n\t\t\t// supported areas (such as within <pre> and <textarea> tags).\n\t\t\tconst matches = Array.from(result.matchAll(/<svg/g)).reverse();\n\t\t\tfor (const match of matches) {\n\t\t\t\tconst startTagIndex = match.index ?? 0;\n\t\t\t\tconst closeTagIndex = result.indexOf(\"</svg\", startTagIndex);\n\t\t\t\tif (closeTagIndex < 0) {\n\t\t\t\t\t// Malformed SVG without a closing tag\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst start = result.substring(0, startTagIndex);\n\t\t\t\tlet svg = result.substring(startTagIndex, closeTagIndex);\n\t\t\t\tconst end = result.substring(closeTagIndex);\n\t\t\t\tsvg = svg.replace(/\\r?\\n/g, \"\");\n\t\t\t\tresult = start + svg + end;\n\t\t\t}\n\t\t}\n\t\tresult = fixCleanCssTidySelectors(html, result);\n\n\t\treturn result;\n\t},\n\tasync minifyCSS(css, options = {}) {\n\t\tconst adjustedOptions = adjustMinifyCSSOptions(options);\n\n\t\tcss = css.replaceAll(/@TEMPLATE_EXPRESSION\\(\\);:/g, \"--TEMPLATE-EXPRESSION:\");\n\t\tconst output = await new CleanCSS({\n\t\t\t...adjustedOptions,\n\t\t\treturnPromise: true,\n\t\t}).minify(css);\n\n\t\tif (output.errors?.length) throw new Error(output.errors.join(\"\\n\\n\"));\n\n\t\t// If there are warnings, return the unminified CSS.\n\t\t// CleanCSS can sometimes struggle with our preprocessed CSS due to the replaced template expressions.\n\t\tif (output.warnings?.length) console.log(css, output.styles);\n\t\tif (output.warnings.length) {\n\t\t\tconsole.warn(output.warnings.join(\"\\n\\n\"));\n\t\t\tconsole.warn(\n\t\t\t\t\"minify-literals: warnings during CSS minification, file was skipped. See above for details.\",\n\t\t\t);\n\t\t\treturn css.replace(/(\\n)|(\\r)/g, \"\");\n\t\t}\n\n\t\toutput.styles = output.styles.replaceAll(\"--TEMPLATE-EXPRESSION:\", \"@TEMPLATE_EXPRESSION();:\");\n\t\toutput.styles = fixCleanCssTidySelectors(css, output.styles);\n\t\treturn output.styles;\n\t},\n\tsplitHTMLByPlaceholder(html, placeholder) {\n\t\tconst parts = html.split(placeholder);\n\t\t// Make the last character (a semicolon) optional. See above.\n\t\tif (placeholder.endsWith(\";\")) {\n\t\t\tconst withoutSemicolon = placeholder.substring(0, placeholder.length - 1);\n\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\tparts.splice(i, 1, ...(parts[i]?.split(withoutSemicolon) ?? []));\n\t\t\t}\n\t\t}\n\n\t\treturn parts;\n\t},\n};\n\nexport function adjustMinifyCSSOptions(options: CleanCSS.Options = {}) {\n\tconst level = options.level;\n\n\tconst plugin = {\n\t\tlevel1: {\n\t\t\tvalue: (_name: any, value: string) => {\n\t\t\t\tif (!value.startsWith(\"@TEMPLATE_EXPRESSION\") || value.endsWith(\";\")) return value;\n\n\t\t\t\t// The CSS minifier has removed the semicolon from the placeholder\n\t\t\t\t// and we need to add it back.\n\t\t\t\treturn `${value};`;\n\t\t\t},\n\t\t},\n\t};\n\n\treturn {\n\t\t...options,\n\t\tlevel,\n\t\tplugins: [plugin],\n\t};\n}\n\n// Should be fixed in clean-css https://github.com/clean-css/clean-css/issues/996, but is still happening\nfunction fixCleanCssTidySelectors(original: string, result: string) {\n\tconst regex = /(::?.+\\((.*)\\))[\\s\\r\\n]*{/gm;\n\tlet match: RegExpMatchArray | null;\n\t// biome-ignore lint/suspicious/noAssignInExpressions: this is fine\n\twhile ((match = regex.exec(original)) != null) {\n\t\tconst pseudoClass = match[1] ?? \"\";\n\t\tconst parameters = match[2];\n\n\t\tif (!parameters?.match(/\\s/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parametersWithoutSpaces = parameters.replace(/\\s/g, \"\");\n\t\tconst resultPseudoClass = pseudoClass.replace(parameters, parametersWithoutSpaces);\n\t\tconst resultStartIndex = result.indexOf(resultPseudoClass);\n\t\tif (resultStartIndex < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst resultEndIndex = resultStartIndex + resultPseudoClass.length;\n\t\t// Restore the original pseudo class with spaces\n\t\tresult = result.substring(0, resultStartIndex) + pseudoClass + result.substring(resultEndIndex);\n\t}\n\n\treturn result;\n}\n"],"mappings":"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","names":[]}