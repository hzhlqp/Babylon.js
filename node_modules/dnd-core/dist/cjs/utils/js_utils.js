"use strict";
// cheap lodash replacements
Object.defineProperty(exports, "__esModule", { value: true });
exports.intersection = exports.xor = exports.isObject = exports.isString = exports.without = exports.get = void 0;
/**
 * drop-in replacement for _.get
 * @param obj
 * @param path
 * @param defaultValue
 */
function get(obj, path, defaultValue) {
    return path
        .split('.')
        .reduce((a, c) => (a && a[c] ? a[c] : defaultValue || null), obj);
}
exports.get = get;
/**
 * drop-in replacement for _.without
 */
function without(items, item) {
    return items.filter((i) => i !== item);
}
exports.without = without;
/**
 * drop-in replacement for _.isString
 * @param input
 */
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
/**
 * drop-in replacement for _.isString
 * @param input
 */
function isObject(input) {
    return typeof input === 'object';
}
exports.isObject = isObject;
/**
 * replacement for _.xor
 * @param itemsA
 * @param itemsB
 */
function xor(itemsA, itemsB) {
    const map = new Map();
    const insertItem = (item) => {
        map.set(item, map.has(item) ? map.get(item) + 1 : 1);
    };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    map.forEach((count, key) => {
        if (count === 1) {
            result.push(key);
        }
    });
    return result;
}
exports.xor = xor;
/**
 * replacement for _.intersection
 * @param itemsA
 * @param itemsB
 */
function intersection(itemsA, itemsB) {
    return itemsA.filter((t) => itemsB.indexOf(t) > -1);
}
exports.intersection = intersection;
