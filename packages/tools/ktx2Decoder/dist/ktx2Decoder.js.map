{"version":3,"file":"ktx2Decoder.js","sourceRoot":"","sources":["../src/ktx2Decoder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Resources used for the implementation:\r\n *  - 3js KTX2 loader: https://github.com/mrdoob/three.js/blob/dfb5c23ce126ec845e4aa240599915fef5375797/examples/jsm/loaders/KTX2Loader.js\r\n *  - Universal Texture Transcoders: https://github.com/KhronosGroup/Universal-Texture-Transcoders\r\n *  - KTX2 specification: http://github.khronos.org/KTX-Specification/\r\n *  - KTX2 binaries to convert files: https://github.com/KhronosGroup/KTX-Software/releases\r\n *  - KTX specification: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html\r\n *  - KTX-Software: https://github.com/KhronosGroup/KTX-Software\r\n */\r\nimport * as KTX2 from \"core/Materials/Textures/ktx2decoderTypes\";\r\n\r\nimport type { IKTX2_ImageDesc } from \"./ktx2FileReader\";\r\nimport { KTX2FileReader, SupercompressionScheme } from \"./ktx2FileReader\";\r\nimport { TranscoderManager } from \"./transcoderManager\";\r\nimport { LiteTranscoder_UASTC_ASTC } from \"./Transcoders/liteTranscoder_UASTC_ASTC\";\r\nimport { LiteTranscoder_UASTC_BC7 } from \"./Transcoders/liteTranscoder_UASTC_BC7\";\r\nimport { LiteTranscoder_UASTC_RGBA_UNORM } from \"./Transcoders/liteTranscoder_UASTC_RGBA_UNORM\";\r\nimport { LiteTranscoder_UASTC_RGBA_SRGB } from \"./Transcoders/liteTranscoder_UASTC_RGBA_SRGB\";\r\nimport { LiteTranscoder_UASTC_R8_UNORM } from \"./Transcoders/liteTranscoder_UASTC_R8_UNORM\";\r\nimport { LiteTranscoder_UASTC_RG8_UNORM } from \"./Transcoders/liteTranscoder_UASTC_RG8_UNORM\";\r\nimport { MSCTranscoder } from \"./Transcoders/mscTranscoder\";\r\nimport { ZSTDDecoder } from \"./zstddec\";\r\nimport { TranscodeDecisionTree } from \"./transcodeDecisionTree\";\r\n\r\nconst isPowerOfTwo = (value: number) => {\r\n    return (value & (value - 1)) === 0 && value !== 0;\r\n};\r\n\r\n/**\r\n * Class for decoding KTX2 files\r\n *\r\n */\r\nexport class KTX2Decoder {\r\n    private _transcoderMgr: TranscoderManager;\r\n    private _zstdDecoder: ZSTDDecoder;\r\n\r\n    public static DefaultDecoderOptions: KTX2.IKTX2DecoderOptions = {};\r\n\r\n    constructor() {\r\n        this._transcoderMgr = new TranscoderManager();\r\n    }\r\n\r\n    public decode(data: Uint8Array, caps: KTX2.ICompressedFormatCapabilities, options?: KTX2.IKTX2DecoderOptions): Promise<KTX2.IDecodedData> {\r\n        const finalOptions = { ...options, ...KTX2Decoder.DefaultDecoderOptions };\r\n\r\n        return Promise.resolve().then(() => {\r\n            const kfr = new KTX2FileReader(data);\r\n\r\n            if (!kfr.isValid()) {\r\n                throw new Error(\"Invalid KT2 file: wrong signature\");\r\n            }\r\n\r\n            kfr.parse();\r\n\r\n            if (kfr.needZSTDDecoder) {\r\n                if (!this._zstdDecoder) {\r\n                    this._zstdDecoder = new ZSTDDecoder();\r\n                }\r\n\r\n                return this._zstdDecoder.init().then(() => {\r\n                    return this._decodeData(kfr, caps, finalOptions);\r\n                });\r\n            }\r\n\r\n            return this._decodeData(kfr, caps, finalOptions);\r\n        });\r\n    }\r\n\r\n    private _decodeData(kfr: KTX2FileReader, caps: KTX2.ICompressedFormatCapabilities, options?: KTX2.IKTX2DecoderOptions): Promise<KTX2.IDecodedData> {\r\n        const width = kfr.header.pixelWidth;\r\n        const height = kfr.header.pixelHeight;\r\n        const srcTexFormat = kfr.textureFormat;\r\n\r\n        const decisionTree = new TranscodeDecisionTree(srcTexFormat, kfr.hasAlpha, isPowerOfTwo(width) && isPowerOfTwo(height), caps, options);\r\n\r\n        if (options?.transcodeFormatDecisionTree) {\r\n            decisionTree.parseTree(options?.transcodeFormatDecisionTree);\r\n        }\r\n\r\n        const transcodeFormat = decisionTree.transcodeFormat;\r\n        const engineFormat = decisionTree.engineFormat;\r\n        const roundToMultiple4 = decisionTree.roundToMultiple4;\r\n\r\n        const transcoder = this._transcoderMgr.findTranscoder(srcTexFormat, transcodeFormat, kfr.isInGammaSpace, options?.bypassTranscoders);\r\n\r\n        if (transcoder === null) {\r\n            throw new Error(\r\n                `no transcoder found to transcode source texture format \"${KTX2.SourceTextureFormat[srcTexFormat]}\" to format \"${KTX2.TranscodeTarget[transcodeFormat]}\"`\r\n            );\r\n        }\r\n\r\n        const mipmaps: Array<KTX2.IMipmap> = [];\r\n        const dataPromises: Array<Promise<Uint8Array | null>> = [];\r\n        const decodedData: KTX2.IDecodedData = {\r\n            width: 0,\r\n            height: 0,\r\n            transcodedFormat: engineFormat,\r\n            mipmaps,\r\n            isInGammaSpace: kfr.isInGammaSpace,\r\n            hasAlpha: kfr.hasAlpha,\r\n            transcoderName: transcoder.getName(),\r\n        };\r\n\r\n        let firstImageDescIndex = 0;\r\n\r\n        for (let level = 0; level < kfr.header.levelCount; level++) {\r\n            if (level > 0) {\r\n                firstImageDescIndex += Math.max(kfr.header.layerCount, 1) * kfr.header.faceCount * Math.max(kfr.header.pixelDepth >> (level - 1), 1);\r\n            }\r\n\r\n            const levelWidth = Math.floor(width / (1 << level)) || 1;\r\n            const levelHeight = Math.floor(height / (1 << level)) || 1;\r\n\r\n            const numImagesInLevel = kfr.header.faceCount; // note that cubemap are not supported yet (see KTX2FileReader), so faceCount == 1\r\n            const levelImageByteLength = ((levelWidth + 3) >> 2) * ((levelHeight + 3) >> 2) * kfr.dfdBlock.bytesPlane[0];\r\n\r\n            const levelUncompressedByteLength = kfr.levels[level].uncompressedByteLength;\r\n\r\n            let levelDataBuffer = kfr.data.buffer;\r\n\r\n            let levelDataOffset = kfr.levels[level].byteOffset + kfr.data.byteOffset;\r\n            let imageOffsetInLevel = 0;\r\n\r\n            if (kfr.header.supercompressionScheme === SupercompressionScheme.ZStandard) {\r\n                levelDataBuffer = this._zstdDecoder.decode(new Uint8Array(levelDataBuffer, levelDataOffset, kfr.levels[level].byteLength), levelUncompressedByteLength);\r\n                levelDataOffset = 0;\r\n            }\r\n\r\n            if (level === 0) {\r\n                decodedData.width = roundToMultiple4 ? (levelWidth + 3) & ~3 : levelWidth;\r\n                decodedData.height = roundToMultiple4 ? (levelHeight + 3) & ~3 : levelHeight;\r\n            }\r\n\r\n            for (let imageIndex = 0; imageIndex < numImagesInLevel; imageIndex++) {\r\n                let encodedData: Uint8Array;\r\n                let imageDesc: IKTX2_ImageDesc | null = null;\r\n\r\n                if (kfr.header.supercompressionScheme === SupercompressionScheme.BasisLZ) {\r\n                    imageDesc = kfr.supercompressionGlobalData.imageDescs![firstImageDescIndex + imageIndex];\r\n\r\n                    encodedData = new Uint8Array(levelDataBuffer, levelDataOffset + imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength + imageDesc.alphaSliceByteLength);\r\n                } else {\r\n                    encodedData = new Uint8Array(levelDataBuffer, levelDataOffset + imageOffsetInLevel, levelImageByteLength);\r\n\r\n                    imageOffsetInLevel += levelImageByteLength;\r\n                }\r\n\r\n                const mipmap: KTX2.IMipmap = {\r\n                    data: null,\r\n                    width: levelWidth,\r\n                    height: levelHeight,\r\n                };\r\n\r\n                const transcodedData = transcoder\r\n                    .transcode(srcTexFormat, transcodeFormat, level, levelWidth, levelHeight, levelUncompressedByteLength, kfr, imageDesc, encodedData)\r\n                    .then((data) => {\r\n                        mipmap.data = data;\r\n                        return data;\r\n                    })\r\n                    .catch((reason) => {\r\n                        decodedData.errors = decodedData.errors ?? \"\";\r\n                        decodedData.errors += reason + \"\\n\" + reason.stack + \"\\n\";\r\n                        return null;\r\n                    });\r\n\r\n                dataPromises.push(transcodedData);\r\n\r\n                mipmaps.push(mipmap);\r\n            }\r\n        }\r\n\r\n        return Promise.all(dataPromises).then(() => {\r\n            return decodedData;\r\n        });\r\n    }\r\n}\r\n\r\n// Put in the order you want the transcoders to be used in priority\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_ASTC);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_BC7);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RGBA_UNORM);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RGBA_SRGB);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_R8_UNORM);\r\nTranscoderManager.RegisterTranscoder(LiteTranscoder_UASTC_RG8_UNORM);\r\nTranscoderManager.RegisterTranscoder(MSCTranscoder); // catch all transcoder - will throw an error if the format can't be transcoded\r\n"]}