{"version":3,"file":"texture.js","sourceRoot":"","sources":["../../src/labs/texture.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene } from \"core/scene\";\r\nimport { CubeTexture } from \"core/Materials/Textures/cubeTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"core/Materials/Textures/internalTexture\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * WebGL Pixel Formats\r\n */\r\nexport const enum PixelFormat {\r\n    DEPTH_COMPONENT = 0x1902,\r\n    ALPHA = 0x1906,\r\n    RGB = 0x1907,\r\n    RGBA = 0x1908,\r\n    LUMINANCE = 0x1909,\r\n    LUMINANCE_ALPHA = 0x190a,\r\n}\r\n\r\n/**\r\n * WebGL Pixel Types\r\n */\r\nexport const enum PixelType {\r\n    UNSIGNED_BYTE = 0x1401,\r\n    UNSIGNED_SHORT_4_4_4_4 = 0x8033,\r\n    UNSIGNED_SHORT_5_5_5_1 = 0x8034,\r\n    UNSIGNED_SHORT_5_6_5 = 0x8363,\r\n}\r\n\r\n/**\r\n * WebGL Texture Magnification Filter\r\n */\r\nexport const enum TextureMagFilter {\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n}\r\n\r\n/**\r\n * WebGL Texture Minification Filter\r\n */\r\nexport const enum TextureMinFilter {\r\n    NEAREST = 0x2600,\r\n    LINEAR = 0x2601,\r\n    NEAREST_MIPMAP_NEAREST = 0x2700,\r\n    LINEAR_MIPMAP_NEAREST = 0x2701,\r\n    NEAREST_MIPMAP_LINEAR = 0x2702,\r\n    LINEAR_MIPMAP_LINEAR = 0x2703,\r\n}\r\n\r\n/**\r\n * WebGL Texture Wrap Modes\r\n */\r\nexport const enum TextureWrapMode {\r\n    REPEAT = 0x2901,\r\n    CLAMP_TO_EDGE = 0x812f,\r\n    MIRRORED_REPEAT = 0x8370,\r\n}\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport interface TextureData {\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height of image\r\n     */\r\n    height: number;\r\n    /**\r\n     * Format of pixels in data\r\n     */\r\n    format: PixelFormat;\r\n    /**\r\n     * Row byte alignment of pixels in data\r\n     */\r\n    alignment: number;\r\n    /**\r\n     * Pixel data\r\n     */\r\n    data: ArrayBufferView;\r\n}\r\n\r\n/**\r\n * Wraps sampling parameters for a WebGL texture\r\n */\r\nexport interface SamplingParameters {\r\n    /**\r\n     * Magnification mode when upsampling from a WebGL texture\r\n     */\r\n    magFilter?: TextureMagFilter;\r\n    /**\r\n     * Minification mode when upsampling from a WebGL texture\r\n     */\r\n    minFilter?: TextureMinFilter;\r\n    /**\r\n     * X axis wrapping mode when sampling out of a WebGL texture bounds\r\n     */\r\n    wrapS?: TextureWrapMode;\r\n    /**\r\n     * Y axis wrapping mode when sampling out of a WebGL texture bounds\r\n     */\r\n    wrapT?: TextureWrapMode;\r\n    /**\r\n     * Anisotropic filtering samples\r\n     */\r\n    maxAnisotropy?: number;\r\n}\r\n\r\n/**\r\n * Represents a valid WebGL texture source for use in texImage2D\r\n */\r\nexport type TextureSource = TextureData | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;\r\n\r\n/**\r\n * A generic set of texture mipmaps (where index 0 has the largest dimension)\r\n */\r\nexport type Mipmaps<T> = Array<T>;\r\n\r\n/**\r\n * A set of 6 cubemap arranged in the order [+x, -x, +y, -y, +z, -z]\r\n */\r\nexport type Faces<T> = Array<T>;\r\n\r\n/**\r\n * A set of texture mipmaps specifically for 2D textures in WebGL (where index 0 has the largest dimension)\r\n */\r\nexport type Mipmaps2D = Mipmaps<TextureSource>;\r\n\r\n/**\r\n * A set of texture mipmaps specifically for cubemap textures in WebGL (where index 0 has the largest dimension)\r\n */\r\nexport type MipmapsCube = Mipmaps<Faces<TextureSource>>;\r\n\r\n/**\r\n * A minimal WebGL cubemap descriptor\r\n */\r\nexport class TextureCube {\r\n    /**\r\n     * Returns the width of a face of the texture or 0 if not available\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get Width(): number {\r\n        return this.source && this.source[0] && this.source[0][0] ? this.source[0][0].width : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the height of a face of the texture or 0 if not available\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get Height(): number {\r\n        return this.source && this.source[0] && this.source[0][0] ? this.source[0][0].height : 0;\r\n    }\r\n\r\n    /**\r\n     * constructor\r\n     * @param internalFormat WebGL pixel format for the texture on the GPU\r\n     * @param type WebGL pixel type of the supplied data and texture on the GPU\r\n     * @param source An array containing mipmap levels of faces, where each mipmap level is an array of faces and each face is a TextureSource object\r\n     */\r\n    constructor(\r\n        public internalFormat: PixelFormat,\r\n        public type: PixelType,\r\n        public source: MipmapsCube = []\r\n    ) {}\r\n}\r\n\r\n/**\r\n * A static class providing methods to aid working with Bablyon textures.\r\n */\r\nexport class TextureUtils {\r\n    /**\r\n     * A prefix used when storing a babylon texture object reference on a Spectre texture object\r\n     */\r\n    public static BabylonTextureKeyPrefix = \"__babylonTexture_\";\r\n\r\n    /**\r\n     * Controls anisotropic filtering for deserialized textures.\r\n     */\r\n    public static MaxAnisotropy = 4;\r\n\r\n    /**\r\n     * Returns a BabylonCubeTexture instance from a Spectre texture cube, subject to sampling parameters.\r\n     * If such a texture has already been requested in the past, this texture will be returned, otherwise a new one will be created.\r\n     * The advantage of this is to enable working with texture objects without the need to initialize on the GPU until desired.\r\n     * @param scene A Babylon Scene instance\r\n     * @param textureCube A Spectre TextureCube object\r\n     * @param automaticMipmaps Pass true to enable automatic mipmap generation where possible (requires power of images)\r\n     * @param environment Specifies that the texture will be used as an environment\r\n     * @param singleLod Specifies that the texture will be a singleLod (for environment)\r\n     * @returns Babylon cube texture\r\n     */\r\n    public static GetBabylonCubeTexture(scene: Scene, textureCube: TextureCube, automaticMipmaps: boolean, environment = false, singleLod = false): CubeTexture {\r\n        if (!textureCube) {\r\n            throw new Error(\"no texture cube provided\");\r\n        }\r\n\r\n        let parameters: SamplingParameters;\r\n        if (environment) {\r\n            parameters = singleLod ? TextureUtils._EnvironmentSingleMipSampling : TextureUtils._EnvironmentSampling;\r\n        } else {\r\n            parameters = {\r\n                magFilter: TextureMagFilter.NEAREST,\r\n                minFilter: TextureMinFilter.NEAREST,\r\n                wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n                wrapT: TextureWrapMode.CLAMP_TO_EDGE,\r\n            };\r\n        }\r\n\r\n        const key = TextureUtils.BabylonTextureKeyPrefix + parameters.magFilter + \"\" + parameters.minFilter + \"\" + parameters.wrapS + \"\" + parameters.wrapT;\r\n\r\n        let babylonTexture: CubeTexture = (<any>textureCube)[key];\r\n\r\n        if (!babylonTexture) {\r\n            //initialize babylon texture\r\n            babylonTexture = new CubeTexture(\"\", scene);\r\n            if (environment) {\r\n                babylonTexture.lodGenerationOffset = TextureUtils.EnvironmentLODOffset;\r\n                babylonTexture.lodGenerationScale = TextureUtils.EnvironmentLODScale;\r\n            }\r\n\r\n            babylonTexture.gammaSpace = false;\r\n\r\n            const internalTexture = new InternalTexture(scene.getEngine(), InternalTextureSource.CubeRaw);\r\n            const glTexture = internalTexture._hardwareTexture?.underlyingResource;\r\n            //babylon properties\r\n            internalTexture.isCube = true;\r\n            internalTexture.generateMipMaps = false;\r\n\r\n            babylonTexture._texture = internalTexture;\r\n\r\n            TextureUtils.ApplySamplingParameters(babylonTexture, parameters);\r\n\r\n            const maxMipLevel = automaticMipmaps ? 0 : textureCube.source.length - 1;\r\n            let texturesUploaded = 0;\r\n\r\n            const textureComplete = function () {\r\n                return texturesUploaded === (maxMipLevel + 1) * 6;\r\n            };\r\n\r\n            const uploadFace = function (i: number, level: number, face: TextureSource) {\r\n                if (!glTexture) {\r\n                    return;\r\n                }\r\n\r\n                if (i === 0 && level === 0) {\r\n                    internalTexture.width = face.width;\r\n                    internalTexture.height = face.height;\r\n                }\r\n\r\n                const gl = (<any>scene.getEngine())._gl;\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, glTexture);\r\n                (scene.getEngine() as Engine)._unpackFlipY(false);\r\n                if (face instanceof HTMLElement || face instanceof ImageData) {\r\n                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, textureCube.internalFormat, textureCube.internalFormat, textureCube.type, <any>face);\r\n                } else {\r\n                    const textureData = <TextureData>face;\r\n                    gl.texImage2D(\r\n                        gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\r\n                        level,\r\n                        textureCube.internalFormat,\r\n                        textureData.width,\r\n                        textureData.height,\r\n                        0,\r\n                        textureData.format,\r\n                        textureCube.type,\r\n                        textureData.data\r\n                    );\r\n                }\r\n\r\n                texturesUploaded++;\r\n\r\n                if (textureComplete()) {\r\n                    //generate mipmaps\r\n                    if (automaticMipmaps) {\r\n                        const w = face.width;\r\n                        const h = face.height;\r\n                        const isPot = (w !== 0 && w & (w - 1)) === 0 && (h !== 0 && h & (h - 1)) === 0;\r\n                        if (isPot) {\r\n                            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n                        }\r\n                    }\r\n\r\n                    // Upload Separate lods in case there is no support for texture lod.\r\n                    if (environment && !scene.getEngine().getCaps().textureLOD && !singleLod) {\r\n                        const mipSlices = 3;\r\n                        for (let i = 0; i < mipSlices; i++) {\r\n                            const lodKey = TextureUtils.BabylonTextureKeyPrefix + \"lod\" + i;\r\n                            let lod: CubeTexture = (<any>textureCube)[lodKey];\r\n\r\n                            //initialize lod texture if it doesn't already exist\r\n                            if (lod == null && textureCube.Width) {\r\n                                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                                const smoothness = i / (mipSlices - 1);\r\n                                const roughness = 1 - smoothness;\r\n                                const kMinimumVariance = 0.0005;\r\n                                const alphaG = roughness * roughness + kMinimumVariance;\r\n                                const microsurfaceAverageSlopeTexels = alphaG * textureCube.Width;\r\n\r\n                                const environmentSpecularLOD = TextureUtils.EnvironmentLODScale * Math.log2(microsurfaceAverageSlopeTexels) + TextureUtils.EnvironmentLODOffset;\r\n\r\n                                const maxLODIndex = textureCube.source.length - 1;\r\n                                const mipmapIndex = Math.min(Math.max(Math.round(environmentSpecularLOD), 0), maxLODIndex);\r\n\r\n                                lod = TextureUtils.GetBabylonCubeTexture(\r\n                                    scene,\r\n                                    new TextureCube(PixelFormat.RGBA, PixelType.UNSIGNED_BYTE, [textureCube.source[mipmapIndex]]),\r\n                                    false,\r\n                                    true,\r\n                                    true\r\n                                );\r\n\r\n                                if (i === 0) {\r\n                                    internalTexture._lodTextureLow = lod;\r\n                                } else if (i === 1) {\r\n                                    internalTexture._lodTextureMid = lod;\r\n                                } else {\r\n                                    internalTexture._lodTextureHigh = lod;\r\n                                }\r\n\r\n                                (<any>textureCube)[lodKey] = lod;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    internalTexture.isReady = true;\r\n                }\r\n\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\r\n                scene.getEngine().resetTextureCache();\r\n            };\r\n\r\n            for (let i = 0; i <= maxMipLevel; i++) {\r\n                const faces = textureCube.source[i];\r\n                for (let j = 0; j < faces.length; j++) {\r\n                    const face = faces[j];\r\n                    if (face instanceof HTMLImageElement && !face.complete) {\r\n                        face.addEventListener(\r\n                            \"load\",\r\n                            () => {\r\n                                uploadFace(j, i, face);\r\n                            },\r\n                            false\r\n                        );\r\n                    } else {\r\n                        uploadFace(j, i, face);\r\n                    }\r\n                }\r\n            }\r\n\r\n            scene.getEngine().resetTextureCache();\r\n\r\n            babylonTexture.isReady = () => {\r\n                return textureComplete();\r\n            };\r\n\r\n            (<any>textureCube)[key] = babylonTexture;\r\n        }\r\n\r\n        return babylonTexture;\r\n    }\r\n\r\n    /**\r\n     * Applies Spectre SamplingParameters to a Babylon texture by directly setting texture parameters on the internal WebGLTexture as well as setting Babylon fields\r\n     * @param babylonTexture Babylon texture to apply texture to (requires the Babylon texture has an initialize _texture field)\r\n     * @param parameters Spectre SamplingParameters to apply\r\n     */\r\n    public static ApplySamplingParameters(babylonTexture: BaseTexture, parameters: SamplingParameters) {\r\n        const scene = babylonTexture.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const gl = (<any>scene.getEngine())._gl;\r\n\r\n        const target = babylonTexture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\r\n\r\n        const internalTexture = babylonTexture._texture;\r\n        if (!internalTexture) {\r\n            return;\r\n        }\r\n        const glTexture = internalTexture._hardwareTexture?.underlyingResource;\r\n        gl.bindTexture(target, glTexture);\r\n\r\n        if (parameters.magFilter != null) {\r\n            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, parameters.magFilter);\r\n        }\r\n        if (parameters.minFilter != null) {\r\n            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, parameters.minFilter);\r\n        }\r\n        if (parameters.wrapS != null) {\r\n            gl.texParameteri(target, gl.TEXTURE_WRAP_S, parameters.wrapS);\r\n        }\r\n        if (parameters.wrapT != null) {\r\n            gl.texParameteri(target, gl.TEXTURE_WRAP_T, parameters.wrapT);\r\n        }\r\n\r\n        //set babylon wrap modes from sampling parameter\r\n        switch (parameters.wrapS) {\r\n            case TextureWrapMode.REPEAT:\r\n                babylonTexture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n                break;\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                break;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                babylonTexture.wrapU = Texture.MIRROR_ADDRESSMODE;\r\n                break;\r\n            default:\r\n                babylonTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        switch (parameters.wrapT) {\r\n            case TextureWrapMode.REPEAT:\r\n                babylonTexture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n                break;\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                break;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                babylonTexture.wrapV = Texture.MIRROR_ADDRESSMODE;\r\n                break;\r\n            default:\r\n                babylonTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (parameters.maxAnisotropy != null && parameters.maxAnisotropy > 1) {\r\n            const anisotropicExt = gl.getExtension(\"EXT_texture_filter_anisotropic\");\r\n            if (anisotropicExt) {\r\n                const maxAnisotropicSamples = gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\r\n                const maxAnisotropy = Math.min(parameters.maxAnisotropy, maxAnisotropicSamples);\r\n                gl.texParameterf(target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);\r\n                babylonTexture.anisotropicFilteringLevel = maxAnisotropy;\r\n            }\r\n        }\r\n\r\n        gl.bindTexture(target, null);\r\n        scene.getEngine().resetTextureCache();\r\n    }\r\n\r\n    private static _EnvironmentSampling: SamplingParameters = {\r\n        magFilter: TextureMagFilter.LINEAR,\r\n        minFilter: TextureMinFilter.LINEAR_MIPMAP_LINEAR,\r\n        wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n        wrapT: TextureWrapMode.CLAMP_TO_EDGE,\r\n        maxAnisotropy: 1,\r\n    };\r\n\r\n    private static _EnvironmentSingleMipSampling: SamplingParameters = {\r\n        magFilter: TextureMagFilter.LINEAR,\r\n        minFilter: TextureMinFilter.LINEAR,\r\n        wrapS: TextureWrapMode.CLAMP_TO_EDGE,\r\n        wrapT: TextureWrapMode.CLAMP_TO_EDGE,\r\n        maxAnisotropy: 1,\r\n    };\r\n\r\n    //from \"/Internal/Lighting.EnvironmentFilterScale\" in Engine/*/Configuration.cpp\r\n    /**\r\n     * Environment preprocessing dedicated value (Internal Use or Advanced only).\r\n     */\r\n    public static EnvironmentLODScale = 0.8;\r\n    /**\r\n     * Environment preprocessing dedicated value (Internal Use or Advanced only)..\r\n     */\r\n    public static EnvironmentLODOffset = 1.0;\r\n}\r\n"]}