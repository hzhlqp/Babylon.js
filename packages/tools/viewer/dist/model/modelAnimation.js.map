{"version":3,"file":"modelAnimation.js","sourceRoot":"","sources":["../../src/model/modelAnimation.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Vector3 } from \"core/Maths/math.vector\";\r\n// eslint-disable-next-line import/no-internal-modules\r\nimport type { AnimationGroup, Animatable } from \"core/Animations/index\";\r\n\r\n/**\r\n * Animation play mode enum - is the animation looping or playing once\r\n */\r\nexport enum AnimationPlayMode {\r\n    ONCE,\r\n    LOOP,\r\n}\r\n\r\n/**\r\n * An enum representing the current state of an animation object\r\n */\r\nexport enum AnimationState {\r\n    INIT,\r\n    PLAYING,\r\n    PAUSED,\r\n    STOPPED,\r\n    ENDED,\r\n}\r\n\r\n/**\r\n * The different type of easing functions available\r\n */\r\nexport enum EasingFunction {\r\n    Linear = 0,\r\n    CircleEase = 1,\r\n    BackEase = 2,\r\n    BounceEase = 3,\r\n    CubicEase = 4,\r\n    ElasticEase = 5,\r\n    ExponentialEase = 6,\r\n    PowerEase = 7,\r\n    QuadraticEase = 8,\r\n    QuarticEase = 9,\r\n    QuinticEase = 10,\r\n    SineEase = 11,\r\n}\r\n\r\n/**\r\n * Defines a simple animation to be applied to a model (scale).\r\n */\r\nexport interface ModelAnimationConfiguration {\r\n    /**\r\n     * Time of animation, in seconds\r\n     */\r\n    time: number;\r\n\r\n    /**\r\n     * Scale to apply\r\n     */\r\n    scaling?: Vector3;\r\n\r\n    /**\r\n     * Easing function to apply\r\n     * See SPECTRE.EasingFunction\r\n     */\r\n    easingFunction?: number;\r\n\r\n    /**\r\n     * An Easing mode to apply to the easing function\r\n     * See BABYLON.EasingFunction\r\n     */\r\n    easingMode?: number;\r\n}\r\n\r\n/**\r\n * This interface can be implemented to define new types of ModelAnimation objects.\r\n */\r\nexport interface IModelAnimation {\r\n    /**\r\n     * Current animation state (playing, stopped etc')\r\n     */\r\n    readonly state: AnimationState;\r\n    /**\r\n     * the name of the animation\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Get the max numbers of frame available in the animation group\r\n     *\r\n     * In correlation to an array, this would be \".length\"\r\n     */\r\n    readonly frames: number;\r\n    /**\r\n     * Get the current frame playing right now.\r\n     * This can be used to poll the frame currently playing (and, for example, display a progress bar with the data)\r\n     *\r\n     * In correlation to an array, this would be the current index\r\n     */\r\n    readonly currentFrame: number;\r\n    /**\r\n     * Animation's FPS value\r\n     */\r\n    readonly fps: number;\r\n    /**\r\n     * Get or set the animation's speed ration (Frame-to-fps)\r\n     */\r\n    speedRatio: number;\r\n    /**\r\n     * Gets or sets the aimation's play mode.\r\n     */\r\n    playMode: AnimationPlayMode;\r\n    /**\r\n     * Start the animation\r\n     */\r\n    start(): void;\r\n    /**\r\n     * Stop the animation.\r\n     * This will fail silently if the animation group is already stopped.\r\n     */\r\n    stop(): void;\r\n    /**\r\n     * Pause the animation\r\n     * This will fail silently if the animation is not currently playing\r\n     */\r\n    pause(): void;\r\n    /**\r\n     * Reset this animation\r\n     */\r\n    reset(): void;\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    restart(): void;\r\n    /**\r\n     * Go to a specific\r\n     * @param frameNumber the frame number to go to\r\n     */\r\n    goToFrame(frameNumber: number): void;\r\n    /**\r\n     * Dispose this animation\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * The GroupModelAnimation is an implementation of the IModelAnimation interface using BABYLON's\r\n * native GroupAnimation class.\r\n */\r\nexport class GroupModelAnimation implements IModelAnimation {\r\n    private _playMode: AnimationPlayMode;\r\n    private _state: AnimationState;\r\n\r\n    /**\r\n     * Create a new GroupModelAnimation object using an AnimationGroup object\r\n     * @param _animationGroup The animation group to base the class on\r\n     */\r\n    constructor(private _animationGroup: AnimationGroup) {\r\n        this._state = AnimationState.INIT;\r\n        this._playMode = AnimationPlayMode.LOOP;\r\n\r\n        this._animationGroup.onAnimationEndObservable.add(() => {\r\n            this._state = AnimationState.ENDED;\r\n            this.stop();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the animation's name\r\n     */\r\n    public get name() {\r\n        return this._animationGroup.name;\r\n    }\r\n\r\n    /**\r\n     * Get the current animation's state\r\n     */\r\n    public get state() {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Gets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._animationGroup.speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        this._animationGroup.speedRatio = value;\r\n    }\r\n\r\n    /**\r\n     * Get the max numbers of frame available in the animation group\r\n     *\r\n     * In correlation to an array, this would be \".length\"\r\n     */\r\n    public get frames(): number {\r\n        return this._animationGroup.to - this._animationGroup.from;\r\n    }\r\n\r\n    /**\r\n     * Get the current frame playing right now.\r\n     * This can be used to poll the frame currently playing (and, for example, display a progress bar with the data)\r\n     *\r\n     * In correlation to an array, this would be the current index\r\n     */\r\n    public get currentFrame(): number {\r\n        if (this._animationGroup.targetedAnimations[0] && this._animationGroup.targetedAnimations[0].animation.runtimeAnimations[0]) {\r\n            return this._animationGroup.targetedAnimations[0].animation.runtimeAnimations[0].currentFrame - this._animationGroup.from;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the FPS value of this animation\r\n     */\r\n    public get fps(): number {\r\n        // get the first currentFrame found\r\n        for (let i = 0; i < this._animationGroup.animatables.length; ++i) {\r\n            const animatable: Animatable = this._animationGroup.animatables[i];\r\n            const animations = animatable.getAnimations();\r\n            if (!animations || !animations.length) {\r\n                continue;\r\n            }\r\n            for (let idx = 0; idx < animations.length; ++idx) {\r\n                if (animations[idx].animation && animations[idx].animation.framePerSecond) {\r\n                    return animations[idx].animation.framePerSecond;\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * What is the animation'S play mode (looping or played once)\r\n     */\r\n    public get playMode(): AnimationPlayMode {\r\n        return this._playMode;\r\n    }\r\n\r\n    /**\r\n     * Set the play mode.\r\n     * If the animation is played, it will continue playing at least once more, depending on the new play mode set.\r\n     * If the animation is not set, the will be initialized and will wait for the user to start playing it.\r\n     */\r\n    public set playMode(value: AnimationPlayMode) {\r\n        if (value === this._playMode) {\r\n            return;\r\n        }\r\n\r\n        this._playMode = value;\r\n\r\n        if (this.state === AnimationState.PLAYING) {\r\n            this._animationGroup.play(this._playMode === AnimationPlayMode.LOOP);\r\n        } else {\r\n            this._animationGroup.reset();\r\n            this._state = AnimationState.INIT;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the animation group\r\n     */\r\n    reset() {\r\n        this._animationGroup.reset();\r\n    }\r\n\r\n    /**\r\n     * Restart the animation group\r\n     */\r\n    restart() {\r\n        if (this.state === AnimationState.PAUSED) {\r\n            this._animationGroup.restart();\r\n        } else {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param frameNumber Go to a specific frame in the animation\r\n     */\r\n    goToFrame(frameNumber: number) {\r\n        this._animationGroup.goToFrame(frameNumber + this._animationGroup.from);\r\n    }\r\n\r\n    /**\r\n     * Start playing the animation.\r\n     */\r\n    public start() {\r\n        this._animationGroup.start(this.playMode === AnimationPlayMode.LOOP, this.speedRatio);\r\n        if (this._animationGroup.isStarted) {\r\n            this._state = AnimationState.PLAYING;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    pause() {\r\n        this._animationGroup.pause();\r\n        this._state = AnimationState.PAUSED;\r\n    }\r\n\r\n    /**\r\n     * Stop the animation.\r\n     * This will fail silently if the animation group is already stopped.\r\n     */\r\n    public stop() {\r\n        // do not trigger stop if animation state is ended.\r\n        if (this._state === AnimationState.ENDED) {\r\n            return;\r\n        }\r\n        this._animationGroup.stop();\r\n        if (!this._animationGroup.isStarted) {\r\n            this._state = AnimationState.STOPPED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this animation object.\r\n     */\r\n    public dispose() {\r\n        this._animationGroup.dispose();\r\n    }\r\n}\r\n"]}