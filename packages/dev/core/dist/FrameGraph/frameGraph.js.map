{"version":3,"file":"frameGraph.js","sourceRoot":"","sources":["../../src/FrameGraph/frameGraph.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type {\r\n    Scene,\r\n    AbstractEngine,\r\n    RenderTargetWrapper,\r\n    FrameGraphTextureCreationOptions,\r\n    FrameGraphTextureHandle,\r\n    FrameGraphTextureDescription,\r\n    Nullable,\r\n    FrameGraphTask,\r\n} from \"core/index\";\r\nimport { FrameGraphPass } from \"./Passes/pass\";\r\nimport { FrameGraphRenderPass } from \"./Passes/renderPass\";\r\nimport { FrameGraphCullPass } from \"./Passes/cullPass\";\r\nimport { FrameGraphRenderContext } from \"./frameGraphRenderContext\";\r\nimport { FrameGraphContext } from \"./frameGraphContext\";\r\nimport { FrameGraphTextureManager } from \"./frameGraphTextureManager\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { getDimensionsFromTextureSize, textureSizeIsObject } from \"../Materials/Textures/textureCreationOptions\";\r\n\r\nenum FrameGraphPassType {\r\n    Render = 0,\r\n    Cull = 1,\r\n    Compute = 2,\r\n}\r\n\r\n/**\r\n * Class used to implement a frame graph\r\n * @experimental\r\n */\r\nexport class FrameGraph {\r\n    /** @internal */\r\n    public readonly _passContext: FrameGraphContext;\r\n    /** @internal */\r\n    public readonly _renderContext: FrameGraphRenderContext;\r\n\r\n    private readonly _engine: AbstractEngine;\r\n    private readonly _textureManager: FrameGraphTextureManager;\r\n    private _tasks: FrameGraphTask[] = [];\r\n    private _currentProcessedTask: FrameGraphTask | null = null;\r\n\r\n    /**\r\n     * Observable raised when the node render graph is built\r\n     */\r\n    public onBuildObservable = new Observable<FrameGraph>();\r\n\r\n    /**\r\n     * Gets the engine used by the frame graph\r\n     */\r\n    public get engine() {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Constructs the frame graph\r\n     * @param engine defines the hosting engine\r\n     * @param debugTextures defines a boolean indicating that textures created by the frame graph should be visible in the inspector\r\n     * @param scene defines the scene in which debugging textures are to be created\r\n     */\r\n    constructor(engine: AbstractEngine, debugTextures = false, scene?: Scene) {\r\n        this._engine = engine;\r\n        this._textureManager = new FrameGraphTextureManager(this._engine, debugTextures, scene);\r\n        this._passContext = new FrameGraphContext();\r\n        this._renderContext = new FrameGraphRenderContext(this._engine, this._textureManager);\r\n    }\r\n\r\n    /**\r\n     * Gets a task by name\r\n     * @param name Name of the task to get\r\n     * @returns The task or undefined if not found\r\n     */\r\n    public getTaskByName<T extends FrameGraphTask>(name: string): T | undefined {\r\n        return this._tasks.find((t) => t.name === name) as T;\r\n    }\r\n\r\n    /**\r\n     * Adds a task to the frame graph\r\n     * @param task Task to add\r\n     */\r\n    public addTask(task: FrameGraphTask): void {\r\n        if (this._currentProcessedTask !== null) {\r\n            throw new Error(`FrameGraph.addTask: Can't add the task \"${task.name}\" while another task is currently building (task: ${this._currentProcessedTask.name}).`);\r\n        }\r\n\r\n        this._tasks.push(task);\r\n    }\r\n\r\n    /**\r\n     * Adds a render pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The render pass created\r\n     */\r\n    public addRenderPass(name: string, whenTaskDisabled = false): FrameGraphRenderPass {\r\n        return this._addPass(name, FrameGraphPassType.Render, whenTaskDisabled) as FrameGraphRenderPass;\r\n    }\r\n\r\n    /**\r\n     * Adds a cull pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The cull pass created\r\n     */\r\n    public addCullPass(name: string, whenTaskDisabled = false): FrameGraphCullPass {\r\n        return this._addPass(name, FrameGraphPassType.Cull, whenTaskDisabled) as FrameGraphCullPass;\r\n    }\r\n\r\n    private _addPass(name: string, passType: FrameGraphPassType, whenTaskDisabled = false): FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass {\r\n        if (!this._currentProcessedTask) {\r\n            throw new Error(\"FrameGraph: A pass must be created during a Task.record execution only.\");\r\n        }\r\n\r\n        let pass: FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass;\r\n\r\n        switch (passType) {\r\n            case FrameGraphPassType.Render:\r\n                pass = new FrameGraphRenderPass(name, this._currentProcessedTask, this._renderContext, this._engine);\r\n                break;\r\n            case FrameGraphPassType.Cull:\r\n                pass = new FrameGraphCullPass(name, this._currentProcessedTask, this._passContext, this._engine);\r\n                break;\r\n            default:\r\n                pass = new FrameGraphPass(name, this._currentProcessedTask, this._passContext);\r\n                break;\r\n        }\r\n\r\n        this._currentProcessedTask._addPass(pass, whenTaskDisabled);\r\n\r\n        return pass;\r\n    }\r\n\r\n    /**\r\n     * Builds the frame graph.\r\n     * This method should be called after all tasks have been added to the frame graph (FrameGraph.addTask) and before the graph is executed (FrameGraph.execute).\r\n     */\r\n    public build(): void {\r\n        this._textureManager.releaseTextures(false);\r\n\r\n        for (const task of this._tasks) {\r\n            task._reset();\r\n\r\n            this._currentProcessedTask = task;\r\n\r\n            task.record();\r\n\r\n            this._currentProcessedTask = null;\r\n        }\r\n\r\n        this._textureManager.allocateTextures();\r\n\r\n        for (const task of this._tasks) {\r\n            task._checkTask();\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the frame graph is ready to be executed\r\n     * This method must be called after the graph has been built (FrameGraph.build called)!\r\n     * @param timeout Timeout in ms between retries (default is 16)\r\n     * @returns The promise that resolves when the graph is ready\r\n     */\r\n    public whenReadyAsync(timeout = 16): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const checkReady = () => {\r\n                let ready = true;\r\n                for (const task of this._tasks) {\r\n                    ready &&= task.isReady();\r\n                }\r\n                if (ready) {\r\n                    resolve();\r\n                } else {\r\n                    setTimeout(checkReady, timeout);\r\n                }\r\n            };\r\n\r\n            checkReady();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes the frame graph.\r\n     */\r\n    public execute(): void {\r\n        this._renderContext._bindRenderTarget();\r\n\r\n        for (const task of this._tasks) {\r\n            const passes = task._getPasses();\r\n\r\n            for (const pass of passes) {\r\n                pass._execute();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Imports a texture into the frame graph\r\n     * @param name Name of the texture\r\n     * @param texture Texture to import\r\n     * @param handle Existing handle to use for the texture. If not provided (default), a new handle will be created.\r\n     * @returns The handle to the texture\r\n     */\r\n    public importTexture(name: string, texture: RenderTargetWrapper, handle?: FrameGraphTextureHandle): FrameGraphTextureHandle {\r\n        return this._textureManager.importTexture(name, texture, handle);\r\n    }\r\n\r\n    /**\r\n     * Gets the creation options of a texture\r\n     * @param handle Handle of the texture\r\n     * @param cloneOptions If true, the options will be cloned before being returned (default is false)\r\n     * @returns The creation options of the texture\r\n     */\r\n    public getTextureCreationOptions(handle: FrameGraphTextureHandle, cloneOptions = false): FrameGraphTextureCreationOptions {\r\n        const creationOptions = this._textureManager.getTextureCreationOptions(handle);\r\n\r\n        return cloneOptions\r\n            ? {\r\n                  size: getDimensionsFromTextureSize(creationOptions.size),\r\n                  options: { ...creationOptions.options },\r\n                  sizeIsPercentage: creationOptions.sizeIsPercentage,\r\n              }\r\n            : creationOptions;\r\n    }\r\n\r\n    /**\r\n     * Gets the description of a texture\r\n     * @param handle Handle of the texture\r\n     * @returns The description of the texture\r\n     */\r\n    public getTextureDescription(handle: FrameGraphTextureHandle): FrameGraphTextureDescription {\r\n        const creationOptions = this.getTextureCreationOptions(handle);\r\n\r\n        const size = !creationOptions.sizeIsPercentage\r\n            ? textureSizeIsObject(creationOptions.size)\r\n                ? { width: creationOptions.size.width, height: creationOptions.size.height }\r\n                : { width: creationOptions.size, height: creationOptions.size }\r\n            : this._textureManager.getAbsoluteDimensions(creationOptions.size);\r\n\r\n        return {\r\n            size,\r\n            options: { ...creationOptions.options },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a texture handle or creates a new texture if the handle is not provided.\r\n     * @param handle If provided, will simply return the handle\r\n     * @param newTextureName Name of the new texture to create\r\n     * @param creationOptions Options to use when creating the new texture\r\n     * @returns The handle to the texture. If handle is not provided, newTextureName and creationOptions must be provided.\r\n     */\r\n    public getTextureHandleOrCreateTexture(handle?: FrameGraphTextureHandle, newTextureName?: string, creationOptions?: FrameGraphTextureCreationOptions): FrameGraphTextureHandle {\r\n        if (handle === undefined) {\r\n            if (newTextureName === undefined || creationOptions === undefined) {\r\n                throw new Error(\"getTextureHandleOrCreateTexture: Either handle or newTextureName and creationOptions must be provided.\");\r\n            }\r\n            return this.createRenderTargetTexture(newTextureName, creationOptions);\r\n        }\r\n        return handle;\r\n    }\r\n\r\n    /**\r\n     * Gets a texture from a handle\r\n     * @param handle The handle of the texture\r\n     * @returns The texture or null if not found\r\n     */\r\n    public getTexture(handle: FrameGraphTextureHandle): Nullable<RenderTargetWrapper> {\r\n        return this._textureManager.getTextureFromHandle(handle);\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target texture\r\n     * @param name Name of the texture\r\n     * @param creationOptions Options to use when creating the texture\r\n     * @param multiTargetMode If true, the texture will be created in multi target mode (default is false). In this mode, a handle is created for each target separately, in addition to the handle created for the main render target texture itself.\r\n     * @returns The handle to the texture\r\n     */\r\n    public createRenderTargetTexture(name: string, creationOptions: FrameGraphTextureCreationOptions, multiTargetMode = false): FrameGraphTextureHandle {\r\n        return this._textureManager.createRenderTargetTexture(name, !!this._currentProcessedTask, creationOptions, multiTargetMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a handle which is not associated with any texture.\r\n     * Call resolveDanglingHandle to associate the handle with a valid texture handle.\r\n     * @returns The dangling handle\r\n     */\r\n    public createDanglingHandle(): FrameGraphTextureHandle {\r\n        return this._textureManager.createDanglingHandle();\r\n    }\r\n\r\n    /**\r\n     * Associates a texture with a dangling handle\r\n     * @param danglingHandle The dangling handle\r\n     * @param handle The handle to associate with the dangling handle (if not provided, a new texture handle will be created)\r\n     * @param newTextureName The name of the new texture to create (if handle is not provided)\r\n     * @param creationOptions The options to use when creating the new texture (if handle is not provided)\r\n     */\r\n    public resolveDanglingHandle(\r\n        danglingHandle: FrameGraphTextureHandle,\r\n        handle?: FrameGraphTextureHandle,\r\n        newTextureName?: string,\r\n        creationOptions?: FrameGraphTextureCreationOptions\r\n    ) {\r\n        if (handle === undefined) {\r\n            if (newTextureName === undefined || creationOptions === undefined) {\r\n                throw new Error(\"resolveDanglingHandle: Either handle or newTextureName and creationOptions must be provided.\");\r\n            }\r\n            this._textureManager.createRenderTargetTexture(newTextureName, !!this._currentProcessedTask, creationOptions, false, danglingHandle);\r\n            return;\r\n        }\r\n\r\n        this._textureManager.resolveDanglingHandle(danglingHandle, handle);\r\n    }\r\n\r\n    /**\r\n     * Clears the frame graph (remove the tasks and release the textures).\r\n     * The frame graph can be built again after this method is called.\r\n     */\r\n    public clear(): void {\r\n        for (const task of this._tasks) {\r\n            task._reset();\r\n        }\r\n\r\n        this._tasks.length = 0;\r\n        this._textureManager.releaseTextures();\r\n        this._currentProcessedTask = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the frame graph\r\n     */\r\n    public dispose(): void {\r\n        this.clear();\r\n        this._textureManager.dispose();\r\n        this._renderContext._dispose();\r\n    }\r\n}\r\n"]}