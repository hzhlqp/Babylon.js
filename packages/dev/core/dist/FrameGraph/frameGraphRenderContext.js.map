{"version":3,"file":"frameGraphRenderContext.js","sourceRoot":"","sources":["../../src/FrameGraph/frameGraphRenderContext.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, DrawWrapper, IColor4Like, Layer, FrameGraphTextureHandle, Effect, FrameGraphTextureManager, RenderTargetTexture } from \"core/index\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer } from \"../Materials/effectRenderer\";\r\nimport { CopyTextureToTexture } from \"../Misc/copyTextureToTexture\";\r\nimport { FrameGraphContext } from \"./frameGraphContext\";\r\nimport { backbufferColorTextureHandle, backbufferDepthStencilTextureHandle } from \"./frameGraphTypes\";\r\n\r\n/**\r\n * Frame graph context used render passes.\r\n * @experimental\r\n */\r\nexport class FrameGraphRenderContext extends FrameGraphContext {\r\n    private readonly _effectRenderer: EffectRenderer;\r\n    private _currentRenderTargetHandle: FrameGraphTextureHandle;\r\n    private _debugMessageWhenTargetBound: string | undefined;\r\n    private _debugMessageHasBeenPushed = false;\r\n    private _renderTargetIsBound = true;\r\n    private readonly _copyTexture: CopyTextureToTexture;\r\n\r\n    /** @internal */\r\n    constructor(\r\n        private readonly _engine: AbstractEngine,\r\n        private readonly _textureManager: FrameGraphTextureManager\r\n    ) {\r\n        super();\r\n        this._effectRenderer = new EffectRenderer(this._engine);\r\n        this._copyTexture = new CopyTextureToTexture(this._engine);\r\n        this._currentRenderTargetHandle = backbufferColorTextureHandle;\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's color or depth texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's color or depth texture, otherwise false\r\n     */\r\n    public isBackbuffer(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager.isBackbuffer(handle);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's color texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's color texture, otherwise false\r\n     */\r\n    public isBackbufferColor(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager.isBackbufferColor(handle);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's depth texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's depth texture, otherwise false\r\n     */\r\n    public isBackbufferDepthStencil(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager.isBackbufferDepthStencil(handle);\r\n    }\r\n\r\n    /**\r\n     * Clears the current render buffer or the current render target (if any is set up)\r\n     * @param color Defines the color to use\r\n     * @param backBuffer Defines if the back buffer must be cleared\r\n     * @param depth Defines if the depth buffer must be cleared\r\n     * @param stencil Defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void {\r\n        this._applyRenderTarget();\r\n        this._engine.clear(color, backBuffer, depth, stencil);\r\n    }\r\n\r\n    /**\r\n     * Clears the color attachments of the current render target\r\n     * @param color Defines the color to use\r\n     * @param attachments The attachments to clear\r\n     */\r\n    public clearColorAttachments(color: Nullable<IColor4Like>, attachments: number[]): void {\r\n        this._applyRenderTarget();\r\n        this._engine.bindAttachments(attachments);\r\n        this._engine.clear(color, true, false, false);\r\n    }\r\n\r\n    /**\r\n     * Binds the attachments to the current render target\r\n     * @param attachments The attachments to bind\r\n     */\r\n    public bindAttachments(attachments: number[]): void {\r\n        this._applyRenderTarget();\r\n        this._engine.bindAttachments(attachments);\r\n    }\r\n\r\n    /**\r\n     * Generates mipmaps for the current render target\r\n     */\r\n    public generateMipMaps(): void {\r\n        const texture = this._textureManager.getTextureFromHandle(this._currentRenderTargetHandle);\r\n        if (!texture) {\r\n            // Texture is backbuffer, no need to generate mipmaps\r\n            return;\r\n        }\r\n        if (this._renderTargetIsBound) {\r\n            // we can't generate the mipmaps if the texture is bound as a render target\r\n            this._flushDebugMessages();\r\n            this._engine.unBindFramebuffer(texture);\r\n            this._renderTargetIsBound = false;\r\n        }\r\n        this._engine.generateMipmaps(texture.texture!);\r\n    }\r\n\r\n    /**\r\n     * Sets the texture sampling mode for a given texture handle\r\n     * @param handle Handle of the texture to set the sampling mode for\r\n     * @param samplingMode Sampling mode to set\r\n     */\r\n    public setTextureSamplingMode(handle: FrameGraphTextureHandle, samplingMode: number): void {\r\n        const internalTexture = this._textureManager.getTextureFromHandle(handle)?.texture!;\r\n        if (internalTexture && internalTexture.samplingMode !== samplingMode) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, internalTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture handle to a given effect (resolves the handle to a texture and binds it to the effect)\r\n     * @param effect The effect to bind the texture to\r\n     * @param name The name of the texture in the effect\r\n     * @param handle The handle of the texture to bind\r\n     */\r\n    public bindTextureHandle(effect: Effect, name: string, handle: FrameGraphTextureHandle): void {\r\n        const texture = this._textureManager.getTextureFromHandle(handle);\r\n        if (texture) {\r\n            effect._bindTexture(name, texture.texture!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the depth states for the current render target\r\n     * @param depthTest If true, depth testing is enabled\r\n     * @param depthWrite If true, depth writing is enabled\r\n     */\r\n    public setDepthStates(depthTest: boolean, depthWrite: boolean): void {\r\n        this._engine.setDepthBuffer(depthTest);\r\n        this._engine.setDepthWrite(depthWrite);\r\n    }\r\n\r\n    /**\r\n     * Applies a full-screen effect to the current render target\r\n     * @param drawWrapper The draw wrapper containing the effect to apply\r\n     * @param customBindings The custom bindings to use when applying the effect (optional)\r\n     * @returns True if the effect was applied, otherwise false (effect not ready)\r\n     */\r\n    public applyFullScreenEffect(drawWrapper: DrawWrapper, customBindings?: () => void): boolean {\r\n        if (!drawWrapper.effect?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._applyRenderTarget();\r\n\r\n        const engineDepthMask = this._engine.getDepthWrite(); // for some reasons, depthWrite is not restored by EffectRenderer.restoreStates\r\n\r\n        this._effectRenderer.saveStates();\r\n        this._effectRenderer.setViewport();\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        this._effectRenderer.bindBuffers(drawWrapper.effect);\r\n        customBindings?.();\r\n        this._effectRenderer.draw();\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.setDepthWrite(engineDepthMask);\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Copies a texture to the current render target\r\n     * @param sourceTexture The source texture to copy from\r\n     * @param forceCopyToBackbuffer If true, the copy will be done to the back buffer regardless of the current render target\r\n     */\r\n    public copyTexture(sourceTexture: FrameGraphTextureHandle, forceCopyToBackbuffer = false): void {\r\n        if (forceCopyToBackbuffer) {\r\n            this._bindRenderTarget();\r\n        }\r\n        this._applyRenderTarget();\r\n        this._copyTexture.copy(this._textureManager.getTextureFromHandle(sourceTexture)!.texture!);\r\n    }\r\n\r\n    /**\r\n     * Renders a RenderTargetTexture or a layer\r\n     * @param object The RenderTargetTexture/Layer to render\r\n     */\r\n    public render(object: Layer | RenderTargetTexture): void {\r\n        this._applyRenderTarget();\r\n        object.render();\r\n    }\r\n\r\n    /**\r\n     * Binds a render target texture so that upcoming draw calls will render to it\r\n     * Note: it is a lazy operation, so the render target will only be bound when needed. This way, it is possible to call\r\n     *   this method several times with different render targets without incurring the cost of binding if no draw calls are made\r\n     * @internal\r\n     */\r\n    public _bindRenderTarget(renderTargetHandle: FrameGraphTextureHandle = backbufferColorTextureHandle, debugMessage?: string) {\r\n        if (renderTargetHandle === this._currentRenderTargetHandle) {\r\n            this._flushDebugMessages();\r\n            if (debugMessage !== undefined) {\r\n                this._engine._debugPushGroup?.(debugMessage, 2);\r\n                this._debugMessageWhenTargetBound = undefined;\r\n                this._debugMessageHasBeenPushed = true;\r\n            }\r\n            return;\r\n        }\r\n        this._currentRenderTargetHandle = renderTargetHandle;\r\n        this._debugMessageWhenTargetBound = debugMessage;\r\n        this._renderTargetIsBound = false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _flushDebugMessages() {\r\n        if (this._debugMessageHasBeenPushed) {\r\n            this._engine._debugPopGroup?.(2);\r\n            this._debugMessageHasBeenPushed = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _shareDepth(srcRenderTargetHandle: FrameGraphTextureHandle, dstRenderTargetHandle: FrameGraphTextureHandle) {\r\n        const srcTexture = this._textureManager.getTextureFromHandle(srcRenderTargetHandle);\r\n        const dstTexture = this._textureManager.getTextureFromHandle(dstRenderTargetHandle);\r\n\r\n        if (srcTexture && dstTexture) {\r\n            srcTexture.shareDepth(dstTexture);\r\n        }\r\n    }\r\n\r\n    private _applyRenderTarget() {\r\n        if (this._renderTargetIsBound) {\r\n            return;\r\n        }\r\n\r\n        const handle = this._currentRenderTargetHandle;\r\n        const textureSlot = this._textureManager._textures.get(handle)!;\r\n\r\n        const renderTarget = textureSlot.texture;\r\n\r\n        this._flushDebugMessages();\r\n\r\n        if (!renderTarget) {\r\n            if (handle === backbufferColorTextureHandle || textureSlot.refHandle === backbufferColorTextureHandle) {\r\n                this._engine.restoreDefaultFramebuffer();\r\n            } else if (handle === backbufferDepthStencilTextureHandle || textureSlot.refHandle === backbufferDepthStencilTextureHandle) {\r\n                this._engine.restoreDefaultFramebuffer();\r\n            }\r\n        } else {\r\n            this._engine.bindFramebuffer(renderTarget);\r\n        }\r\n\r\n        if (this._debugMessageWhenTargetBound !== undefined) {\r\n            this._engine._debugPushGroup?.(this._debugMessageWhenTargetBound, 2);\r\n            this._debugMessageWhenTargetBound = undefined;\r\n            this._debugMessageHasBeenPushed = true;\r\n        }\r\n\r\n        this._renderTargetIsBound = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _dispose() {\r\n        this._effectRenderer.dispose();\r\n        this._copyTexture.dispose();\r\n    }\r\n}\r\n"]}