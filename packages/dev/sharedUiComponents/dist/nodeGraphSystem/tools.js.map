{"version":3,"file":"tools.js","sourceRoot":"","sources":["../../src/nodeGraphSystem/tools.ts"],"names":[],"mappings":"AAKA,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,eAAoB,EAAoC,EAAE;IACtF,IAAI,eAAe,EAAE;QACjB,OAAQ,eAAiC,CAAC,IAAI,KAAK,SAAS,CAAC;KAChE;SAAM;QACH,OAAO,KAAK,CAAC;KAChB;AACL,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,IAAe,EAAE,YAA6B,EAAE,YAA4B,EAAE,MAA6B,EAAE,EAAE;IACvI,IAAI,CAAC,OAAO,EAAE,CAAC;IAEf,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;IAEzB,IAAI,YAAY,EAAE;QACd,wFAAwF;QACxF,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACnB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,EACpB,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAEvB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBAC1B,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACxB,WAAW,CAAC,KAAK,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;aAClD;YAED,IAAI,KAAK,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;gBACnC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACxB,WAAW,CAAC,KAAK,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;aAClD;QACL,CAAC,CAAC,CAAC;KACN;IAED,2CAA2C;IAC3C,MAAM,kBAAkB,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,CAAC;IAC3D,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,MAAM,EAAE;QACjD,KAAK,MAAM,QAAQ,IAAI,kBAAkB,EAAE;YACvC,MAAM,SAAS,GAAG,MAAM,EAAE,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YACrD,IAAI,SAAS,EAAE;gBACX,IAAI,YAAY,EAAE;oBACd,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;iBAC/B;gBACD,WAAW,CAAC,SAAS,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;aACtD;SACJ;KACJ;IAED,IAAI,CAAC,YAAY,EAAE;QACf,OAAO;KACV;IAED,kEAAkE;IAClE,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACnB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACzB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACvB,IAAI,CAAC,MAAM,EAAE,CAAC;SACjB;IACL,CAAC,CAAC,CAAC;AACP,CAAC,CAAC","sourcesContent":["import type { GraphCanvasComponent } from \"./graphCanvas\";\r\nimport type { GraphNode } from \"./graphNode\";\r\nimport type { NodeLink } from \"./nodeLink\";\r\nimport type { FramePortData } from \"./types/framePortData\";\r\n\r\nexport const IsFramePortData = (variableToCheck: any): variableToCheck is FramePortData => {\r\n    if (variableToCheck) {\r\n        return (variableToCheck as FramePortData).port !== undefined;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const RefreshNode = (node: GraphNode, visitedNodes?: Set<GraphNode>, visitedLinks?: Set<NodeLink>, canvas?: GraphCanvasComponent) => {\r\n    node.refresh();\r\n\r\n    const links = node.links;\r\n\r\n    if (visitedNodes) {\r\n        // refresh first the nodes so that the right types are assigned to the auto-detect ports\r\n        links.forEach((link) => {\r\n            const nodeA = link.nodeA,\r\n                nodeB = link.nodeB;\r\n\r\n            if (!visitedNodes.has(nodeA)) {\r\n                visitedNodes.add(nodeA);\r\n                RefreshNode(nodeA, visitedNodes, visitedLinks);\r\n            }\r\n\r\n            if (nodeB && !visitedNodes.has(nodeB)) {\r\n                visitedNodes.add(nodeB);\r\n                RefreshNode(nodeB, visitedNodes, visitedLinks);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Invisible endpoints (for teleport nodes)\r\n    const invisibleEndpoints = node.content.invisibleEndpoints;\r\n    if (invisibleEndpoints && invisibleEndpoints.length) {\r\n        for (const endpoint of invisibleEndpoints) {\r\n            const graphNode = canvas?.findNodeFromData(endpoint);\r\n            if (graphNode) {\r\n                if (visitedNodes) {\r\n                    visitedNodes.add(graphNode);\r\n                }\r\n                RefreshNode(graphNode, visitedNodes, visitedLinks);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!visitedLinks) {\r\n        return;\r\n    }\r\n\r\n    // then refresh the links to display the right color between ports\r\n    links.forEach((link) => {\r\n        if (!visitedLinks.has(link)) {\r\n            visitedLinks.add(link);\r\n            link.update();\r\n        }\r\n    });\r\n};\r\n"]}