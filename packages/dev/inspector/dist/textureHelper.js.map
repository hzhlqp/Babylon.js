{"version":3,"file":"textureHelper.js","sourceRoot":"","sources":["../src/textureHelper.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { GlobalState } from \"./components/globalState\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\n\r\n/**\r\n * Defines which channels of the texture to retrieve with {@link TextureHelper.GetTextureDataAsync}.\r\n */\r\nexport interface TextureChannelsToDisplay {\r\n    /**\r\n     * True if the red channel should be included.\r\n     */\r\n    R: boolean;\r\n    /**\r\n     * True if the green channel should be included.\r\n     */\r\n    G: boolean;\r\n    /**\r\n     * True if the blue channel should be included.\r\n     */\r\n    B: boolean;\r\n    /**\r\n     * True if the alpha channel should be included.\r\n     */\r\n    A: boolean;\r\n}\r\n\r\n/**\r\n * Helper class for retrieving texture data.\r\n */\r\nexport class TextureHelper {\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param channels a filter for which of the RGBA channels to return in the result\r\n     * @param globalState the global state to use for rendering the texture\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    public static async GetTextureDataAsync(\r\n        texture: BaseTexture,\r\n        width: number,\r\n        height: number,\r\n        face: number,\r\n        channels: TextureChannelsToDisplay,\r\n        globalState?: GlobalState,\r\n        lod: number = 0\r\n    ): Promise<Uint8Array> {\r\n        if (globalState) {\r\n            globalState.blockMutationUpdates = true;\r\n        }\r\n        try {\r\n            const data = await TextureTools.GetTextureDataAsync(texture, width, height, face, lod);\r\n            if (!channels.R || !channels.G || !channels.B || !channels.A) {\r\n                for (let i = 0; i < width * height * 4; i += 4) {\r\n                    // If alpha is the only channel, just display alpha across all channels\r\n                    if (channels.A && !channels.R && !channels.G && !channels.B) {\r\n                        data[i] = data[i + 3];\r\n                        data[i + 1] = data[i + 3];\r\n                        data[i + 2] = data[i + 3];\r\n                        data[i + 3] = 255;\r\n                        continue;\r\n                    }\r\n                    let r = data[i],\r\n                        g = data[i + 1],\r\n                        b = data[i + 2],\r\n                        a = data[i + 3];\r\n                    // If alpha is not visible, make everything 100% alpha\r\n                    if (!channels.A) {\r\n                        a = 255;\r\n                    }\r\n                    // If only one color channel is selected, map both colors to it. If two are selected, the unused one gets set to 0\r\n                    if (!channels.R) {\r\n                        if (channels.G && !channels.B) {\r\n                            r = g;\r\n                        } else if (channels.B && !channels.G) {\r\n                            r = b;\r\n                        } else {\r\n                            r = 0;\r\n                        }\r\n                    }\r\n                    if (!channels.G) {\r\n                        if (channels.R && !channels.B) {\r\n                            g = r;\r\n                        } else if (channels.B && !channels.R) {\r\n                            g = b;\r\n                        } else {\r\n                            g = 0;\r\n                        }\r\n                    }\r\n                    if (!channels.B) {\r\n                        if (channels.R && !channels.G) {\r\n                            b = r;\r\n                        } else if (channels.G && !channels.R) {\r\n                            b = g;\r\n                        } else {\r\n                            b = 0;\r\n                        }\r\n                    }\r\n                    data[i] = r;\r\n                    data[i + 1] = g;\r\n                    data[i + 2] = b;\r\n                    data[i + 3] = a;\r\n                }\r\n            }\r\n\r\n            //To flip image on Y axis.\r\n            if ((texture as Texture).invertY || texture.isCube) {\r\n                const numberOfChannelsByLine = width * 4;\r\n                const halfHeight = height / 2;\r\n                for (let i = 0; i < halfHeight; i++) {\r\n                    for (let j = 0; j < numberOfChannelsByLine; j++) {\r\n                        const currentCell = j + i * numberOfChannelsByLine;\r\n                        const targetLine = height - i - 1;\r\n                        const targetCell = j + targetLine * numberOfChannelsByLine;\r\n\r\n                        const temp = data[currentCell];\r\n                        data[currentCell] = data[targetCell];\r\n                        data[targetCell] = temp;\r\n                    }\r\n                }\r\n            }\r\n            return data;\r\n        } finally {\r\n            if (globalState) {\r\n                globalState.blockMutationUpdates = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}