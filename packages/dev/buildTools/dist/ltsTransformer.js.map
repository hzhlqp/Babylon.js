{"version":3,"file":"ltsTransformer.js","sourceRoot":"","sources":["../src/ltsTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-console */\r\nimport * as path from \"path\";\r\nimport * as ts from \"typescript\";\r\nimport * as fs from \"fs\";\r\nimport { globSync } from \"glob\";\r\nimport * as chokidar from \"chokidar\";\r\n\r\nimport { removeDir, checkDirectorySync, checkArgs, copyFile } from \"./utils.js\";\r\nimport { transformPackageLocation } from \"./pathTransform.js\";\r\nimport { getPackageMappingByDevName, getPublicPackageName, isValidDevPackageName } from \"./packageMapping.js\";\r\n\r\nconst printer = ts.createPrinter();\r\n\r\n// the function that processes the file\r\nconst processSourceFile = (packageName: string, relativeLTSFile: any, program: { getSourceFile: (arg0: any) => any }, checker: { getSymbolAtLocation: (arg0: any) => any }) => {\r\n    console.log(`Processing ${relativeLTSFile}...`);\r\n    const ltsFile = path.resolve(relativeLTSFile);\r\n    const sourceFile = path.resolve(ltsFile.replace(\"lts\", \"dev\"));\r\n    const relativeToSource = path.relative(path.dirname(ltsFile), \"./src\");\r\n    const srcFileExists = fs.existsSync(sourceFile);\r\n    const source = program.getSourceFile(sourceFile);\r\n    const sourceLTS = program.getSourceFile(ltsFile);\r\n\r\n    const importedSource: any[] = [];\r\n    let inLTS = false;\r\n    const ltsTransformer = (context: any) => {\r\n        function visit(node: ts.Node | undefined): ts.Node | undefined {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            node = ts.visitEachChild(node, visit, context);\r\n            if (!inLTS) {\r\n                // get all exported elements\r\n                const exported = ts.canHaveModifiers(node) && ts.getModifiers(node)?.find((m: { kind: any }) => m.kind === ts.SyntaxKind.ExportKeyword);\r\n                // const exported2 = node.modifiers && node.modifiers.find((m) => m.kind === ts.SyntaxKind.ExportKeyword);\r\n                if (exported) {\r\n                    // find the first identifier (name of class/function/enum)\r\n                    const found = node.getChildren().find((c: { kind: any }) => c.kind === ts.SyntaxKind.Identifier);\r\n                    if (found) {\r\n                        // console.log(found.getText());\r\n                        importedSource.push(found.getText());\r\n                    } else {\r\n                        // check for declarations\r\n                        const found3 = node.getChildren().find((c: { kind: any }) => c.kind === ts.SyntaxKind.VariableDeclarationList) as ts.VariableDeclarationList;\r\n                        if (found3 && (found3 as ts.VariableDeclarationList).declarations) {\r\n                            const foundIdentifier = found3.declarations[0].getChildren().find((c: { kind: any }) => c.kind === ts.SyntaxKind.Identifier) as ts.Identifier;\r\n                            importedSource.push(foundIdentifier.getText());\r\n                        }\r\n                    }\r\n                } else if (ts.isImportSpecifier(node)) {\r\n                    importedSource.push(node.getText());\r\n                    // } else if (ts.isImportTypeNode(node)) {\r\n                    //     const found = node.getChildren().find((c) => c.kind === ts.SyntaxKind.Identifier);\r\n                    //     if (found) {\r\n                    //         // console.log(found.getText());\r\n                    //         importedSource.push(found.getText());\r\n                    //     }\r\n                } else if (ts.isTypeAliasDeclaration(node)) {\r\n                    const symbol = checker.getSymbolAtLocation(node.name);\r\n                    importedSource.push(symbol.getName());\r\n                }\r\n            }\r\n            if (inLTS) {\r\n                // is it an import declaration?\r\n                if (ts.isImportDeclaration(node)) {\r\n                    // check import clause\r\n                    const clause = node.importClause;\r\n                    const leftImports: any[] = [];\r\n                    // check if there are needed imports\r\n                    if (clause && clause.namedBindings && clause.namedBindings.kind === ts.SyntaxKind.NamedImports) {\r\n                        const imports = clause.namedBindings.elements;\r\n                        const leftOvers = imports.filter((i) => !importedSource.includes(i.getText()));\r\n                        // const empty = imports.every((i) => importedSource.includes(i.getText()));\r\n                        if (leftOvers.length === 0) {\r\n                            // remove this import clause, it is empty.\r\n                            return;\r\n                        } else {\r\n                            leftOvers.forEach((i) => {\r\n                                leftImports.push(ts.factory.updateImportSpecifier(i, false, i.propertyName, i.name));\r\n                            });\r\n                        }\r\n                    }\r\n                    const transformed = transformLocation(packageName, (node.moduleSpecifier as any).text); // TODO any is still needed\r\n                    // check if we are loading from the same source\r\n                    if (!transformed) {\r\n                        return node;\r\n                    }\r\n                    if (clause && clause.namedBindings && clause.namedBindings.kind === ts.SyntaxKind.NamedImports) {\r\n                        // update the import declaration\r\n                        const newClause = ts.factory.updateImportClause(clause, clause.isTypeOnly, clause.name, ts.factory.createNamedImports(leftImports));\r\n                        return ts.factory.updateImportDeclaration(node, node.modifiers, newClause, ts.factory.createStringLiteral(transformed), node.assertClause);\r\n                    } else {\r\n                        return ts.factory.updateImportDeclaration(node, node.modifiers, node.importClause, ts.factory.createStringLiteral(transformed), node.assertClause); // TODO what is the assert clause?\r\n                    }\r\n                } else if (ts.isExportDeclaration(node)) {\r\n                    // check import clause\r\n                    const clause = node.exportClause;\r\n                    if (!node.moduleSpecifier) {\r\n                        return node;\r\n                    }\r\n                    const transformed = transformLocation(packageName, (node.moduleSpecifier as any).text); // TODO any is still needed\r\n                    // check if we are loading from the same source\r\n                    if (!transformed) {\r\n                        return node;\r\n                    }\r\n                    // update the import declaration\r\n                    // const newClause = ts.factory.updateExport(clause, clause.isTypeOnly, clause.name, ts.factory.createNamedImports(leftImports));\r\n                    return ts.factory.updateExportDeclaration(node, node.modifiers, false, clause, ts.factory.createStringLiteral(transformed), undefined); // TODO what is the assert clause?\r\n                } else if (ts.isModuleDeclaration(node)) {\r\n                    const symbol = checker.getSymbolAtLocation(node.name);\r\n                    // is it a module declaration of a file and not an actual module (i.e. 'declare module \"./scene\"')\r\n                    if (\r\n                        symbol.getName().includes('\"') ||\r\n                        symbol.getName().includes(\"'\") ||\r\n                        (ts.canHaveDecorators(node) && ts.getDecorators(node)?.find((c: { kind: any }) => c.kind === ts.SyntaxKind.DeclareKeyword))\r\n                    ) {\r\n                        const transformed = transformLocation(packageName, node.name.text, true);\r\n                        if (transformed) {\r\n                            const literal = ts.factory.createStringLiteral(transformed);\r\n                            return ts.factory.updateModuleDeclaration(node, node.modifiers, literal, node.body);\r\n                        }\r\n                    }\r\n                } else if (ts.isImportTypeNode(node)) {\r\n                    const transformedText = transformLocation(packageName, ((node.argument as ts.LiteralTypeNode).literal as any).text /* TODO any is needed... */);\r\n                    if (transformedText) {\r\n                        // if it is an import type (for type aliases) apply the new transformed location\r\n                        const newArgument = ts.factory.updateLiteralTypeNode(node.argument as ts.LiteralTypeNode, ts.factory.createStringLiteral(transformedText, true));\r\n                        return ts.factory.updateImportTypeNode(node, newArgument, node.assertions, node.qualifier, node.typeArguments, node.isTypeOf);\r\n                    }\r\n                } else if (ts.isTypeAliasDeclaration(node)) {\r\n                    // check if the type alias is already declared in the original source file\r\n                    const symbol = checker.getSymbolAtLocation(node.name);\r\n                    if (importedSource.includes(symbol.getName())) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n\r\n        return (node: any) => ts.visitNode(node, visit);\r\n    };\r\n\r\n    const transformLocation = (packageName: string, sourceLocation: any, relativeSourceOnly?: boolean) => {\r\n        const transformed = transformPackageLocation(sourceLocation, {\r\n            basePackage: packageName,\r\n            buildType: \"es6\", // TODO - was LTS!\r\n            packageOnly: false,\r\n        });\r\n        if (!transformed) {\r\n            console.log(\"Error transforming location: \" + sourceLocation);\r\n            return;\r\n        }\r\n        // get the relative directory\r\n        const relativeLocation = relativeToSource ? transformed.replace(/^.\\//g, relativeToSource + \"/\") : transformed;\r\n        if (relativeSourceOnly) {\r\n            return relativeLocation;\r\n        }\r\n        // from relative to absolute to relative to unix style! FTW :-)\r\n        const abs = path.join(path.dirname(sourceFile), relativeLocation);\r\n        let resolved = path.relative(path.dirname(sourceFile), abs);\r\n        resolved = resolved[0] === \".\" ? resolved : \"./\" + resolved;\r\n        // return unix-style relative path of the source location\r\n        return resolved.split(path.sep).join(path.posix.sep);\r\n    };\r\n    const newLocation = ltsFile.replace(\"src\", \"generated\");\r\n    if (srcFileExists) {\r\n        // Run source file through the transformer\r\n        const result = ts.transform(source, [ltsTransformer]);\r\n        inLTS = true;\r\n        // run the LTS file through the transformer\r\n        const resultLTS = ts.transform(sourceLTS, [ltsTransformer]);\r\n\r\n        // generate the LTS source that will be added to the original source\r\n        const ltsVersion = printer.printFile(resultLTS.transformed[0]);\r\n        // save the LTS source to the generated folder\r\n        checkDirectorySync(path.dirname(newLocation));\r\n        fs.writeFileSync(\r\n            path.resolve(newLocation),\r\n            `${printer.printFile(result.transformed[0])}\r\n    ${ltsVersion}`\r\n        );\r\n    } else {\r\n        console.log(ltsFile, \"no corresponding file in base package. copying.\");\r\n        inLTS = true;\r\n        // run the LTS file through the transformer\r\n        const resultLTS = ts.transform(sourceLTS, [ltsTransformer]);\r\n\r\n        // generate the LTS source that will be added to the original source\r\n        const ltsVersion = printer.printFile(resultLTS.transformed[0]);\r\n        // save the LTS source to the generated folder\r\n        checkDirectorySync(path.dirname(newLocation));\r\n        fs.writeFileSync(path.resolve(newLocation), `${ltsVersion}`);\r\n    }\r\n    console.log(`LTS source saved to ${newLocation}`);\r\n};\r\n\r\nexport const transformLtsCommand = () => {\r\n    const baseDir = path.basename(path.resolve(\".\"));\r\n    const sourceBaseDir = `./../../dev/${baseDir}/src`;\r\n\r\n    // all LTS source files\r\n    const sourceFiles = globSync(\"./src/**/*.ts\");\r\n    // all original sources\r\n    const baseSources = globSync(`${sourceBaseDir}/**/*.ts`);\r\n    const sourceToGenerated = (filePath: any, silent?: boolean) => {\r\n        // check if not in base sources\r\n        const relative = path.relative(sourceBaseDir, filePath);\r\n        const newLocation = path.resolve(\"./generated\", relative);\r\n        const srcLocation = path.resolve(\"./src\", relative);\r\n        if (!fs.existsSync(srcLocation)) {\r\n            copyFile(filePath, newLocation, silent);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    // the project directory we are working in\r\n    // const baseDir = path.basename(path.resolve(\".\"));\r\n    if (!isValidDevPackageName(baseDir)) {\r\n        return;\r\n    }\r\n    const packages = getPackageMappingByDevName(baseDir);\r\n    const packageName = getPublicPackageName(packages.es6);\r\n\r\n    // TODO - setting these variables here will force us to restart the watch if a new file was added.\r\n    // This should be inside the watch function as well, but then it'll take a long time to process.\r\n    // TODO - check if it is quicker to only keep the base sources that will be processed.\r\n    const program = ts.createProgram([...sourceFiles, ...baseSources], {});\r\n    const checker = program.getTypeChecker();\r\n    console.log(`Generating LTS sources for ${baseDir}`);\r\n    removeDir(\"./generated\");\r\n    // copy all original sources to the generated folder. If they have an LTS file it will be overwritten\r\n    baseSources.forEach((src) => sourceToGenerated(src, true));\r\n    // run the LTS transforming\r\n    sourceFiles.forEach((file: string) => {\r\n        processSourceFile(packageName, file, program, checker);\r\n    });\r\n\r\n    if (checkArgs(\"--watch\")) {\r\n        chokidar.watch(baseSources, { ignoreInitial: true, awaitWriteFinish: true }).on(\"all\", (_event: string, filePath: any) => {\r\n            const copied = sourceToGenerated(filePath, false);\r\n            // is this file in the lts version?\r\n            if (!copied && _event !== \"add\") {\r\n                const relative = path.relative(sourceBaseDir, filePath);\r\n                const srcLocation = path.relative(\"./\", path.resolve(\"./src\", relative));\r\n                processSourceFile(packageName, srcLocation, program, checker);\r\n            }\r\n        });\r\n        // TODO: check why this is executed 3 times\r\n        chokidar.watch(sourceFiles, { ignoreInitial: true, awaitWriteFinish: true }).on(\"all\", (_event: any, filePath: any) => {\r\n            processSourceFile(packageName, filePath, program, checker);\r\n        });\r\n    }\r\n};\r\n"]}